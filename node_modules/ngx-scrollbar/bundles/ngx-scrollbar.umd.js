(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/cdk/bidi'), require('@angular/cdk/portal'), require('@angular/cdk/platform'), require('ngx-scrollbar/smooth-scroll'), require('rxjs'), require('rxjs/operators'), require('@angular/platform-browser'), require('@angular/cdk/coercion')) :
    typeof define === 'function' && define.amd ? define('ngx-scrollbar', ['exports', '@angular/core', '@angular/common', '@angular/cdk/bidi', '@angular/cdk/portal', '@angular/cdk/platform', 'ngx-scrollbar/smooth-scroll', 'rxjs', 'rxjs/operators', '@angular/platform-browser', '@angular/cdk/coercion'], factory) :
    (global = global || self, factory(global['ngx-scrollbar'] = {}, global.ng.core, global.ng.common, global.ng.cdk.bidi, global.ng.cdk.portal, global.ng.cdk.platform, global['ngx-scrollbar']['smooth-scroll'], global.rxjs, global.rxjs.operators, global.ng.platformBrowser, global.ng.cdk.coercion));
}(this, (function (exports, core, common, bidi, portal, platform, smoothScroll, rxjs, operators, platformBrowser, coercion) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} doc
     * @return {?}
     */
    function preventSelection(doc) {
        return operators.tap((/**
         * @return {?}
         */
        function () {
            doc.onselectstart = (/**
             * @return {?}
             */
            function () { return false; });
        }));
    }
    /**
     * @param {?} doc
     * @return {?}
     */
    function enableSelection(doc) {
        return operators.tap((/**
         * @return {?}
         */
        function () {
            doc.onselectstart = null;
        }));
    }
    /**
     * @return {?}
     */
    function stopPropagation() {
        return operators.tap((/**
         * @param {?} e
         * @return {?}
         */
        function (e) { return e.stopPropagation(); }));
    }
    /**
     * Check if pointer is within scrollbar bounds
     * @param {?} e
     * @param {?} rect
     * @return {?}
     */
    function isWithinBounds(e, rect) {
        return (e.clientX >= rect.left &&
            e.clientX <= rect.left + rect.width &&
            e.clientY >= rect.top &&
            e.clientY <= rect.top + rect.height);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ScrollViewport = /** @class */ (function () {
        function ScrollViewport(viewPort, document) {
            this.viewPort = viewPort;
            this.document = document;
            this.nativeElement = viewPort.nativeElement;
        }
        Object.defineProperty(ScrollViewport.prototype, "clientHeight", {
            // Get viewport size, clientHeight or clientWidth
            get: 
            // Get viewport size, clientHeight or clientWidth
            /**
             * @return {?}
             */
            function () {
                return this.nativeElement.clientHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "clientWidth", {
            get: /**
             * @return {?}
             */
            function () {
                return this.nativeElement.clientWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollHeight", {
            get: /**
             * @return {?}
             */
            function () {
                return this.nativeElement.scrollHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollWidth", {
            get: /**
             * @return {?}
             */
            function () {
                return this.nativeElement.scrollWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollTop", {
            // Get viewport scroll offset, scrollTop or scrollLeft
            get: 
            // Get viewport scroll offset, scrollTop or scrollLeft
            /**
             * @return {?}
             */
            function () {
                return this.nativeElement.scrollTop;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollLeft", {
            get: /**
             * @return {?}
             */
            function () {
                return this.nativeElement.scrollLeft;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollMaxX", {
            // Get the available scrollable size
            get: 
            // Get the available scrollable size
            /**
             * @return {?}
             */
            function () {
                return this.scrollWidth - this.clientWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "scrollMaxY", {
            get: /**
             * @return {?}
             */
            function () {
                return this.scrollHeight - this.clientHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScrollViewport.prototype, "contentHeight", {
            get: /**
             * @return {?}
             */
            function () {
                return this.contentWrapperElement.clientHeight;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Activate viewport pointer events such as 'hovered' and 'clicked' events
         */
        /**
         * Activate viewport pointer events such as 'hovered' and 'clicked' events
         * @param {?} destroyed
         * @return {?}
         */
        ScrollViewport.prototype.activatePointerEvents = /**
         * Activate viewport pointer events such as 'hovered' and 'clicked' events
         * @param {?} destroyed
         * @return {?}
         */
        function (destroyed) {
            var _this = this;
            this.hovered = new rxjs.Observable((/**
             * @param {?} observer
             * @return {?}
             */
            function (observer) {
                // Stream that emits when pointer is moved over the viewport (used to set the hovered state)
                /** @type {?} */
                var mouseMove = rxjs.fromEvent(_this.nativeElement, 'mousemove', { passive: true }).pipe(stopPropagation());
                // Stream that emits when pointer leaves the viewport (used to remove the hovered state)
                /** @type {?} */
                var mouseLeave = rxjs.fromEvent(_this.nativeElement, 'mouseleave').pipe(operators.map((/**
                 * @return {?}
                 */
                function () { return false; })));
                rxjs.merge(mouseMove, mouseLeave).pipe(operators.tap((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) { return observer.next(e); })), operators.takeUntil(destroyed)).subscribe();
            }));
            this.clicked = new rxjs.Observable((/**
             * @param {?} observer
             * @return {?}
             */
            function (observer) {
                /** @type {?} */
                var mouseDown = rxjs.fromEvent(_this.nativeElement, 'mousedown', { passive: true }).pipe(operators.tap((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) { return observer.next(e); })));
                /** @type {?} */
                var mouseUp = rxjs.fromEvent(_this.nativeElement, 'mouseup', { passive: true }).pipe(operators.tap((/**
                 * @return {?}
                 */
                function () { return observer.next(false); })));
                mouseDown.pipe(operators.switchMap((/**
                 * @return {?}
                 */
                function () { return mouseUp; })), operators.takeUntil(destroyed)).subscribe();
            }));
        };
        /**
         * Set this directive as a non-functional wrapper, called when a custom viewport is used
         */
        /**
         * Set this directive as a non-functional wrapper, called when a custom viewport is used
         * @return {?}
         */
        ScrollViewport.prototype.setAsWrapper = /**
         * Set this directive as a non-functional wrapper, called when a custom viewport is used
         * @return {?}
         */
        function () {
            // In this case the default viewport and the default content wrapper will act as a mask
            this.nativeElement.className = 'ng-native-scrollbar-hider ng-scroll-layer';
            if (this.nativeElement.firstElementChild) {
                this.nativeElement.firstElementChild.className = 'ng-scroll-layer';
            }
        };
        /**
         * Set this directive as  the viewport, called when no custom viewport is used
         */
        /**
         * Set this directive as  the viewport, called when no custom viewport is used
         * @param {?} customClassName
         * @return {?}
         */
        ScrollViewport.prototype.setAsViewport = /**
         * Set this directive as  the viewport, called when no custom viewport is used
         * @param {?} customClassName
         * @return {?}
         */
        function (customClassName) {
            this.nativeElement.className = "ng-native-scrollbar-hider ng-scroll-viewport " + customClassName;
            // Check if the custom viewport has only one child and set it as the content wrapper
            if (this.nativeElement.firstElementChild) {
                this.contentWrapperElement = (/** @type {?} */ (this.nativeElement.firstElementChild));
                this.contentWrapperElement.classList.add('ng-scroll-content');
            }
        };
        /**
         * Scroll viewport vertically
         */
        /**
         * Scroll viewport vertically
         * @param {?} value
         * @return {?}
         */
        ScrollViewport.prototype.scrollYTo = /**
         * Scroll viewport vertically
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.nativeElement.scrollTop = value;
        };
        /**
         * Scroll viewport horizontally
         */
        /**
         * Scroll viewport horizontally
         * @param {?} value
         * @return {?}
         */
        ScrollViewport.prototype.scrollXTo = /**
         * Scroll viewport horizontally
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.nativeElement.scrollLeft = value;
        };
        ScrollViewport.decorators = [
            { type: core.Directive, args: [{
                        selector: '[scrollViewport]'
                    },] }
        ];
        /** @nocollapse */
        ScrollViewport.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        return ScrollViewport;
    }());
    if (false) {
        /** @type {?} */
        ScrollViewport.prototype.nativeElement;
        /** @type {?} */
        ScrollViewport.prototype.contentWrapperElement;
        /** @type {?} */
        ScrollViewport.prototype.hovered;
        /** @type {?} */
        ScrollViewport.prototype.clicked;
        /** @type {?} */
        ScrollViewport.prototype.viewPort;
        /**
         * @type {?}
         * @private
         */
        ScrollViewport.prototype.document;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NG_SCROLLBAR_OPTIONS = new core.InjectionToken('NG_SCROLLBAR_OPTIONS');
    /**
     * @record
     */
    function NgScrollbarOptions() { }
    if (false) {
        /**
         * Sets the scroll axis of the viewport, there are 3 options:
         *
         * - `vertical` Use both vertical and horizontal scrollbar-control
         * - `horizontal` Use both vertical and horizontal scrollbar-control
         * - `all` Use both vertical and horizontal scrollbar-control
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.track;
        /**
         * When to show the scrollbar, and there are 3 options:
         *
         * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar-control
         * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
         * - `always` Scrollbars are always shown even if the viewport is not scrollable
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.visibility;
        /**
         *  Sets the appearance of the scrollbar, there are 2 options:
         *
         * - `standard` (default) scrollbar space will be reserved just like with native scrollbar-control.
         * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.appearance;
        /**
         * Sets the position of each scrollbar, there are 4 options:
         *
         * - `native` (Default) Use the default position like in native scrollbar-control.
         * - `invertY` Inverts vertical scrollbar position
         * - `invertX` Inverts Horizontal scrollbar position
         * - `invertAll` Inverts both scrollbar-control positions
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.position;
        /**
         * Sets the pointer events method
         * Use viewport pointer events  to handle dragging and track click (This makes scrolling work when mouse is over the scrollbar)
         * Use scrollbar pointer events to handle dragging and track click
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.pointerEventsMethod;
        /**
         * A class forwarded to scrollable viewport element
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.viewClass;
        /**
         * A class forwarded to the scrollbar track element
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.trackClass;
        /**
         * A class forwarded to the scrollbar thumb element
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.thumbClass;
        /**
         * The minimum scrollbar thumb size in px
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.minThumbSize;
        /**
         * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.trackClickScrollDuration;
        /**
         * A flag used to enable/disable the scrollbar pointer events
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.pointerEventsDisabled;
        /**
         * Debounce interval for detecting changes via window.resize event
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.windowResizeDebounce;
        /**
         * Debounce interval for detecting changes via ResizeObserver
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.sensorDebounce;
        /**
         * Whether ResizeObserver is disabled
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.sensorDisabled;
        /**
         * Scroll Audit Time
         * @type {?|undefined}
         */
        NgScrollbarOptions.prototype.scrollAuditTime;
    }
    /**
     * Set of attributes added on the scrollbar wrapper
     * @record
     */
    function NgScrollbarState() { }
    if (false) {
        /** @type {?|undefined} */
        NgScrollbarState.prototype.position;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.track;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.appearance;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.visibility;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.deactivated;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.pointerEventsMethod;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.dir;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.verticalUsed;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.horizontalUsed;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.isVerticallyScrollable;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.isHorizontallyScrollable;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.verticalHovered;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.horizontalHovered;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.verticalDragging;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.horizontalDragging;
        /** @type {?|undefined} */
        NgScrollbarState.prototype.scrollbarClicked;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var defaultOptions = {
        viewClass: '',
        trackClass: '',
        thumbClass: '',
        track: 'vertical',
        appearance: 'compact',
        visibility: 'native',
        position: 'native',
        pointerEventsMethod: 'viewport',
        trackClickScrollDuration: 300,
        minThumbSize: 20,
        windowResizeDebounce: 0,
        sensorDebounce: 0,
        scrollAuditTime: 0
    };
    var ScrollbarManager = /** @class */ (function () {
        function ScrollbarManager(options) {
            this.globalOptions = options ? __assign({}, defaultOptions, options) : defaultOptions;
            this.rtlScrollAxisType = platform.getRtlScrollAxisType();
        }
        ScrollbarManager.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        ScrollbarManager.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [NG_SCROLLBAR_OPTIONS,] }] }
        ]; };
        /** @nocollapse */ ScrollbarManager.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function ScrollbarManager_Factory() { return new ScrollbarManager(core.ɵɵinject(NG_SCROLLBAR_OPTIONS, 8)); }, token: ScrollbarManager, providedIn: "root" });
        return ScrollbarManager;
    }());
    if (false) {
        /** @type {?} */
        ScrollbarManager.prototype.globalOptions;
        /** @type {?} */
        ScrollbarManager.prototype.rtlScrollAxisType;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NativeScrollbarSizeFactory = /** @class */ (function () {
        function NativeScrollbarSizeFactory(document, manager, platform) {
            var _this = this;
            this.document = document;
            this.manager = manager;
            this.platform = platform;
            if (platform.isBrowser) {
                rxjs.of(null).pipe(operators.tap((/**
                 * @return {?}
                 */
                function () { return _this._nativeScrollbarSize = new rxjs.BehaviorSubject(_this.getNativeScrollbarSize()); })), operators.tap((/**
                 * @return {?}
                 */
                function () { return _this.nativeScrollbarSize = _this._nativeScrollbarSize.asObservable(); })), operators.switchMap((/**
                 * @return {?}
                 */
                function () { return rxjs.fromEvent(_this.document.defaultView, 'resize', { passive: true }); })), operators.debounceTime((/** @type {?} */ (this.manager.globalOptions.windowResizeDebounce))), operators.tap((/**
                 * @return {?}
                 */
                function () { return _this._nativeScrollbarSize.next(_this.getNativeScrollbarSize()); }))).subscribe();
            }
        }
        /**
         * Get native scrollbar size
         */
        /**
         * Get native scrollbar size
         * @private
         * @return {?}
         */
        NativeScrollbarSizeFactory.prototype.getNativeScrollbarSize = /**
         * Get native scrollbar size
         * @private
         * @return {?}
         */
        function () {
            if (this.platform.ANDROID || this.platform.IOS) {
                return 6;
            }
            /** @type {?} */
            var box = this.document.createElement('div');
            box.className = 'ng-scrollbar-measure';
            this.document.body.appendChild(box);
            /** @type {?} */
            var size = box.getBoundingClientRect().right;
            this.document.body.removeChild(box);
            // if size is 0, return 15 (for MAC OS browsers)
            return size || 15;
        };
        NativeScrollbarSizeFactory.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        NativeScrollbarSizeFactory.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: ScrollbarManager },
            { type: platform.Platform }
        ]; };
        /** @nocollapse */ NativeScrollbarSizeFactory.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function NativeScrollbarSizeFactory_Factory() { return new NativeScrollbarSizeFactory(core.ɵɵinject(common.DOCUMENT), core.ɵɵinject(ScrollbarManager), core.ɵɵinject(platform.Platform)); }, token: NativeScrollbarSizeFactory, providedIn: "root" });
        return NativeScrollbarSizeFactory;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NativeScrollbarSizeFactory.prototype._nativeScrollbarSize;
        /** @type {?} */
        NativeScrollbarSizeFactory.prototype.nativeScrollbarSize;
        /**
         * @type {?}
         * @private
         */
        NativeScrollbarSizeFactory.prototype.document;
        /**
         * @type {?}
         * @private
         */
        NativeScrollbarSizeFactory.prototype.manager;
        /**
         * @type {?}
         * @private
         */
        NativeScrollbarSizeFactory.prototype.platform;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgScrollbar = /** @class */ (function () {
        function NgScrollbar(el, zone, changeDetectorRef, dir, smoothScroll, manager, nativeScrollbarSizeFactory) {
            this.el = el;
            this.zone = zone;
            this.changeDetectorRef = changeDetectorRef;
            this.dir = dir;
            this.smoothScroll = smoothScroll;
            this.manager = manager;
            this.nativeScrollbarSizeFactory = nativeScrollbarSizeFactory;
            /**
             * A class forwarded to scrollable viewport element
             */
            this.viewClass = this.manager.globalOptions.viewClass;
            /**
             * A class forwarded to the scrollbar track element
             */
            this.trackClass = this.manager.globalOptions.trackClass;
            /**
             * A class forwarded to the scrollbar thumb element
             */
            this.thumbClass = this.manager.globalOptions.thumbClass;
            /**
             * Minimum scrollbar thumb size
             */
            this.minThumbSize = this.manager.globalOptions.minThumbSize;
            /**
             * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
             */
            this.trackClickScrollDuration = this.manager.globalOptions.trackClickScrollDuration;
            /**
             * A flag used to enable/disable the scrollbar thumb dragged event
             */
            this.pointerEventsDisabled = this.manager.globalOptions.pointerEventsDisabled;
            /**
             * Sets the pointer events method
             * Use viewport pointer events  to handle dragging and track click (This makes scrolling work when mouse is over the scrollbar)
             * Use scrollbar pointer events to handle dragging and track click
             */
            this.pointerEventsMethod = this.manager.globalOptions.pointerEventsMethod;
            /**
             * Disable custom scrollbar and switch back to native scrollbar
             */
            this.disabled = false;
            /**
             * Sets the supported scroll track of the viewport, there are 3 options:
             *
             * - `vertical` Use both vertical and horizontal scrollbar
             * - `horizontal` Use both vertical and horizontal scrollbar
             * - `all` Use both vertical and horizontal scrollbar
             */
            this.track = this.manager.globalOptions.track;
            /**
             * When to show the scrollbar, and there are 3 options:
             *
             * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
             * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
             * - `always` Scrollbars are always shown even if the viewport is not scrollable
             */
            this.visibility = this.manager.globalOptions.visibility;
            /**
             *  Sets the appearance of the scrollbar, there are 2 options:
             *
             * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
             * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
             */
            this.appearance = this.manager.globalOptions.appearance;
            /**
             * Sets the position of each scrollbar, there are 4 options:
             *
             * - `native` (Default) Use the default position like in native scrollbar.
             * - `invertY` Inverts vertical scrollbar position
             * - `invertX` Inverts Horizontal scrollbar position
             * - `invertAll` Inverts both scrollbar positions
             */
            this.position = this.manager.globalOptions.position;
            /**
             * Debounce interval for detecting changes via ResizeObserver
             */
            this.sensorDebounce = this.manager.globalOptions.sensorDebounce;
            /**
             * Whether ResizeObserver is disabled
             */
            this.sensorDisabled = this.manager.globalOptions.sensorDisabled;
            /**
             * Scroll Audit Time
             */
            this.scrollAuditTime = this.manager.globalOptions.scrollAuditTime;
            /**
             * Steam that emits when scrollbar is updated
             */
            this.updated = new core.EventEmitter();
            /**
             * Set of attributes added on the scrollbar wrapper
             */
            this.state = {};
            /**
             * Stream that destroys components' observables
             */
            this.destroyed = new rxjs.Subject();
        }
        Object.defineProperty(NgScrollbar.prototype, "nativeElement", {
            get: /**
             * @return {?}
             */
            function () {
                return this.el.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Update local state with each change detection
         */
        /**
         * Update local state with each change detection
         * @private
         * @return {?}
         */
        NgScrollbar.prototype.updateState = /**
         * Update local state with each change detection
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var verticalUsed = false;
            /** @type {?} */
            var horizontalUsed = false;
            /** @type {?} */
            var isVerticallyScrollable = false;
            /** @type {?} */
            var isHorizontallyScrollable = false;
            // Check if vertical scrollbar should be displayed
            if (this.track === 'all' || this.track === 'vertical') {
                isVerticallyScrollable = this.viewport.scrollHeight > this.viewport.clientHeight;
                verticalUsed = this.visibility === 'always' || isVerticallyScrollable;
            }
            // Check if horizontal scrollbar should be displayed
            if (this.track === 'all' || this.track === 'horizontal') {
                isHorizontallyScrollable = this.viewport.scrollWidth > this.viewport.clientWidth;
                horizontalUsed = this.visibility === 'always' || isHorizontallyScrollable;
            }
            // Update inner wrapper attributes
            this._updateState({
                position: this.position,
                track: this.track,
                appearance: this.appearance,
                visibility: this.visibility,
                deactivated: this.disabled,
                dir: this.dir.value,
                pointerEventsMethod: this.pointerEventsMethod,
                verticalUsed: verticalUsed,
                horizontalUsed: horizontalUsed,
                isVerticallyScrollable: isVerticallyScrollable,
                isHorizontallyScrollable: isHorizontallyScrollable
            });
        };
        /**
         * @private
         * @param {?} state
         * @return {?}
         */
        NgScrollbar.prototype._updateState = /**
         * @private
         * @param {?} state
         * @return {?}
         */
        function (state) {
            this.state = __assign({}, this.state, state);
            this.changeDetectorRef.detectChanges();
        };
        /**
         * @private
         * @param {?} property
         * @return {?}
         */
        NgScrollbar.prototype.getScrolledByDirection = /**
         * @private
         * @param {?} property
         * @return {?}
         */
        function (property) {
            /** @type {?} */
            var event;
            return this.scrolled.pipe(operators.tap((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return event = e; })), operators.pluck('target', property), operators.pairwise(), operators.filter((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = __read(_a, 2), prev = _b[0], curr = _b[1];
                return prev !== curr;
            })), operators.map((/**
             * @return {?}
             */
            function () { return event; })));
        };
        /**
         * Set hovered state if a scrollbar is being hovered
         */
        /**
         * Set hovered state if a scrollbar is being hovered
         * @param {?} hovered
         * @return {?}
         */
        NgScrollbar.prototype.setHovered = /**
         * Set hovered state if a scrollbar is being hovered
         * @param {?} hovered
         * @return {?}
         */
        function (hovered) {
            var _this = this;
            this.zone.run((/**
             * @return {?}
             */
            function () { return _this._updateState(__assign({}, hovered)); }));
        };
        /**
         * Set dragging state if a scrollbar is being dragged
         */
        /**
         * Set dragging state if a scrollbar is being dragged
         * @param {?} dragging
         * @return {?}
         */
        NgScrollbar.prototype.setDragging = /**
         * Set dragging state if a scrollbar is being dragged
         * @param {?} dragging
         * @return {?}
         */
        function (dragging) {
            var _this = this;
            this.zone.run((/**
             * @return {?}
             */
            function () { return _this._updateState(__assign({}, dragging)); }));
        };
        /**
         * Set clicked state if a scrollbar track is being click
         */
        /**
         * Set clicked state if a scrollbar track is being click
         * @param {?} scrollbarClicked
         * @return {?}
         */
        NgScrollbar.prototype.setClicked = /**
         * Set clicked state if a scrollbar track is being click
         * @param {?} scrollbarClicked
         * @return {?}
         */
        function (scrollbarClicked) {
            var _this = this;
            this.zone.run((/**
             * @return {?}
             */
            function () { return _this._updateState({ scrollbarClicked: scrollbarClicked }); }));
        };
        /**
         * @return {?}
         */
        NgScrollbar.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // Set the viewport based on user choice
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                if (_this.customViewPort) {
                    _this.viewport = _this.customViewPort;
                    _this.defaultViewPort.setAsWrapper();
                }
                else {
                    _this.viewport = _this.defaultViewPort;
                }
                // Activate the selected viewport
                _this.viewport.setAsViewport((/** @type {?} */ (_this.viewClass)));
                /** @type {?} */
                var scrollStream = rxjs.fromEvent(_this.viewport.nativeElement, 'scroll', { passive: true });
                // Throttle scroll event if 'scrollAuditTime' is set
                scrollStream = _this.scrollAuditTime ? scrollStream.pipe(operators.auditTime(_this.scrollAuditTime)) : scrollStream;
                // Initialize scroll streams
                _this.scrolled = new rxjs.Observable((/**
                 * @param {?} observer
                 * @return {?}
                 */
                function (observer) {
                    return scrollStream.pipe(operators.takeUntil(_this.destroyed)).subscribe(observer);
                }));
                _this.verticalScrolled = _this.getScrolledByDirection('scrollTop');
                _this.horizontalScrolled = _this.getScrolledByDirection('scrollLeft');
            }));
        };
        /**
         * @return {?}
         */
        NgScrollbar.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
        function () {
            this.updateState();
        };
        /**
         * @return {?}
         */
        NgScrollbar.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.destroyed.next();
            this.destroyed.complete();
        };
        /**
         * Update local state and the internal scrollbar controls
         */
        /**
         * Update local state and the internal scrollbar controls
         * @return {?}
         */
        NgScrollbar.prototype.update = /**
         * Update local state and the internal scrollbar controls
         * @return {?}
         */
        function () {
            if (!this.state.horizontalUsed) {
                // Auto-height: Set component height to content height
                this.nativeElement.style.height = this.viewport.contentHeight + "px";
            }
            this.updated.next();
            this.changeDetectorRef.detectChanges();
        };
        /**
         * Smooth scroll functions
         */
        /**
         * Smooth scroll functions
         * @param {?} options
         * @return {?}
         */
        NgScrollbar.prototype.scrollTo = /**
         * Smooth scroll functions
         * @param {?} options
         * @return {?}
         */
        function (options) {
            return this.smoothScroll.scrollTo(this.viewport.nativeElement, options);
        };
        /**
         * Scroll to element by reference or selector
         */
        /**
         * Scroll to element by reference or selector
         * @param {?} target
         * @param {?=} options
         * @return {?}
         */
        NgScrollbar.prototype.scrollToElement = /**
         * Scroll to element by reference or selector
         * @param {?} target
         * @param {?=} options
         * @return {?}
         */
        function (target, options) {
            return this.smoothScroll.scrollToElement(this.viewport.nativeElement, target, options);
        };
        NgScrollbar.decorators = [
            { type: core.Component, args: [{
                        selector: 'ng-scrollbar',
                        exportAs: 'ngScrollbar',
                        template: "<div class=\"ng-scrollbar-wrapper\" [ngAttr]=\"state\">\r\n  <div class=\"ng-scroll-viewport-wrapper\"\r\n       (resizeSensor)=\"update()\"\r\n       [sensorDebounce]=\"sensorDebounce\"\r\n       [sensorDisabled]=\"sensorDisabled\">\r\n    <div scrollViewport\r\n         [style]=\"nativeScrollbarSizeFactory.nativeScrollbarSize | async | cssVariable: 'native-scrollbar-size'\">\r\n      <div>\r\n        <ng-content></ng-content>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <ng-container *ngIf=\"!disabled\">\r\n    <scrollbar-x *ngIf=\"state.horizontalUsed\"\r\n                 [attr.scrollable]=\"state.isHorizontallyScrollable\"\r\n                 [attr.fit]=\"state.verticalUsed\">\r\n    </scrollbar-x>\r\n    <scrollbar-y *ngIf=\"state.verticalUsed\"\r\n                 [attr.scrollable]=\"state.isVerticallyScrollable\"\r\n                 [attr.fit]=\"state.horizontalUsed\">\r\n    </scrollbar-y>\r\n  </ng-container>\r\n</div>\r\n\r\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: { '[class.ng-scrollbar]': 'true' },
                        styles: ["::ng-deep .ng-scrollbar-measure{left:0;overflow:scroll;position:fixed;top:-9999px}:host{--scrollbar-border-radius:7px;--scrollbar-padding:4px;--scrollbar-track-color:transparent;--scrollbar-thumb-color:rgba(0, 0, 0, 0.2);--scrollbar-thumb-hover-color:var(--scrollbar-thumb-color);--scrollbar-size:5px;--scrollbar-hover-size:var(--scrollbar-size);--scrollbar-thumb-transition:height ease-out 150ms,width ease-out 150ms;--scrollbar-track-transition:height ease-out 150ms,width ease-out 150ms;display:block;position:relative;height:100%;max-height:100%;max-width:100%}:host>.ng-scrollbar-wrapper{--scrollbar-total-size:calc(var(--scrollbar-size) + var(--scrollbar-padding) * 2);--vertical-scrollbar-size:var(--scrollbar-size);--horizontal-scrollbar-size:var(--scrollbar-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2)}:host>.ng-scrollbar-wrapper[verticalDragging=true],:host>.ng-scrollbar-wrapper[verticalHovered=true]{--vertical-scrollbar-size:var(--scrollbar-hover-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[horizontalDragging=true],:host>.ng-scrollbar-wrapper[horizontalHovered=true]{--horizontal-scrollbar-size:var(--scrollbar-hover-size);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:0;right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:var(--scrollbar-total-size);right:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:var(--scrollbar-total-size);right:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:0;right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{top:0;bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{top:var(--scrollbar-total-size);bottom:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-top:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{bottom:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{left:0;right:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{right:0;left:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]>.scrollbar-control{opacity:0;transition-property:opacity;transition-duration:.4s;transition-delay:.8s}:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:active>.scrollbar-control,:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:focus>.scrollbar-control,:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:hover>.scrollbar-control{opacity:1;transition-duration:.4s;transition-delay:0s}:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-x:auto;overflow-y:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-y:auto;overflow-x:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow:auto}.ng-scroll-viewport-wrapper{overflow:hidden}.ng-scroll-viewport{-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position}::ng-deep .ng-scroll-content{position:relative!important;display:inline-block;min-width:100%}.ng-scroll-layer,.ng-scroll-viewport-wrapper,.ng-scrollbar-wrapper,::ng-deep .ng-scroll-viewport{position:absolute;left:0;right:0;top:0;bottom:0}", "::ng-deep .ng-scrollbar-wrapper[pointerEventsMethod=viewport]>.scrollbar-control{pointer-events:none}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control{position:absolute;display:flex;justify-content:center;align-items:center;transition:var(--scrollbar-track-transition)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}::ng-deep .ng-scrollbar-track{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-track-color);overflow:hidden;transition:var(--scrollbar-track-transition);cursor:default}::ng-deep .ng-scrollbar-thumb{box-sizing:border-box;position:relative;border-radius:inherit;background-color:var(--scrollbar-thumb-color);transform:translateZ(0);transition:var(--scrollbar-thumb-transition)}"]
                    }] }
        ];
        /** @nocollapse */
        NgScrollbar.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: bidi.Directionality },
            { type: smoothScroll.SmoothScrollManager },
            { type: ScrollbarManager },
            { type: NativeScrollbarSizeFactory }
        ]; };
        NgScrollbar.propDecorators = {
            viewClass: [{ type: core.Input }],
            trackClass: [{ type: core.Input }],
            thumbClass: [{ type: core.Input }],
            minThumbSize: [{ type: core.Input }],
            trackClickScrollDuration: [{ type: core.Input }],
            pointerEventsDisabled: [{ type: core.Input }],
            pointerEventsMethod: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            track: [{ type: core.Input }],
            visibility: [{ type: core.Input }],
            appearance: [{ type: core.Input }],
            position: [{ type: core.Input }],
            sensorDebounce: [{ type: core.Input }],
            sensorDisabled: [{ type: core.Input }],
            scrollAuditTime: [{ type: core.Input }],
            updated: [{ type: core.Output }],
            defaultViewPort: [{ type: core.ViewChild, args: [ScrollViewport, { static: true },] }],
            customViewPort: [{ type: core.ContentChild, args: [ScrollViewport, { static: true },] }]
        };
        return NgScrollbar;
    }());
    if (false) {
        /**
         * A class forwarded to scrollable viewport element
         * @type {?}
         */
        NgScrollbar.prototype.viewClass;
        /**
         * A class forwarded to the scrollbar track element
         * @type {?}
         */
        NgScrollbar.prototype.trackClass;
        /**
         * A class forwarded to the scrollbar thumb element
         * @type {?}
         */
        NgScrollbar.prototype.thumbClass;
        /**
         * Minimum scrollbar thumb size
         * @type {?}
         */
        NgScrollbar.prototype.minThumbSize;
        /**
         * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
         * @type {?}
         */
        NgScrollbar.prototype.trackClickScrollDuration;
        /**
         * A flag used to enable/disable the scrollbar thumb dragged event
         * @type {?}
         */
        NgScrollbar.prototype.pointerEventsDisabled;
        /**
         * Sets the pointer events method
         * Use viewport pointer events  to handle dragging and track click (This makes scrolling work when mouse is over the scrollbar)
         * Use scrollbar pointer events to handle dragging and track click
         * @type {?}
         */
        NgScrollbar.prototype.pointerEventsMethod;
        /**
         * Disable custom scrollbar and switch back to native scrollbar
         * @type {?}
         */
        NgScrollbar.prototype.disabled;
        /**
         * Sets the supported scroll track of the viewport, there are 3 options:
         *
         * - `vertical` Use both vertical and horizontal scrollbar
         * - `horizontal` Use both vertical and horizontal scrollbar
         * - `all` Use both vertical and horizontal scrollbar
         * @type {?}
         */
        NgScrollbar.prototype.track;
        /**
         * When to show the scrollbar, and there are 3 options:
         *
         * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
         * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
         * - `always` Scrollbars are always shown even if the viewport is not scrollable
         * @type {?}
         */
        NgScrollbar.prototype.visibility;
        /**
         *  Sets the appearance of the scrollbar, there are 2 options:
         *
         * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
         * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
         * @type {?}
         */
        NgScrollbar.prototype.appearance;
        /**
         * Sets the position of each scrollbar, there are 4 options:
         *
         * - `native` (Default) Use the default position like in native scrollbar.
         * - `invertY` Inverts vertical scrollbar position
         * - `invertX` Inverts Horizontal scrollbar position
         * - `invertAll` Inverts both scrollbar positions
         * @type {?}
         */
        NgScrollbar.prototype.position;
        /**
         * Debounce interval for detecting changes via ResizeObserver
         * @type {?}
         */
        NgScrollbar.prototype.sensorDebounce;
        /**
         * Whether ResizeObserver is disabled
         * @type {?}
         */
        NgScrollbar.prototype.sensorDisabled;
        /**
         * Scroll Audit Time
         * @type {?}
         */
        NgScrollbar.prototype.scrollAuditTime;
        /**
         * Steam that emits when scrollbar is updated
         * @type {?}
         */
        NgScrollbar.prototype.updated;
        /**
         * Default viewport reference
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.defaultViewPort;
        /**
         * Custom viewport reference
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.customViewPort;
        /**
         * Viewport Element
         * @type {?}
         */
        NgScrollbar.prototype.viewport;
        /**
         * Set of attributes added on the scrollbar wrapper
         * @type {?}
         */
        NgScrollbar.prototype.state;
        /**
         * Stream that destroys components' observables
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.destroyed;
        /**
         * Stream that emits on scroll event
         * @type {?}
         */
        NgScrollbar.prototype.scrolled;
        /**
         * Steam that emits scroll event for vertical scrollbar
         * @type {?}
         */
        NgScrollbar.prototype.verticalScrolled;
        /**
         * Steam that emits scroll event for horizontal scrollbar
         * @type {?}
         */
        NgScrollbar.prototype.horizontalScrolled;
        /**
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.el;
        /**
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.zone;
        /**
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.changeDetectorRef;
        /**
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.dir;
        /**
         * @type {?}
         * @private
         */
        NgScrollbar.prototype.smoothScroll;
        /** @type {?} */
        NgScrollbar.prototype.manager;
        /** @type {?} */
        NgScrollbar.prototype.nativeScrollbarSizeFactory;
    }
    /**
     * @record
     */
    function ScrollbarDragging() { }
    if (false) {
        /** @type {?|undefined} */
        ScrollbarDragging.prototype.verticalDragging;
        /** @type {?|undefined} */
        ScrollbarDragging.prototype.horizontalDragging;
    }
    /**
     * @record
     */
    function ScrollbarHovered() { }
    if (false) {
        /** @type {?|undefined} */
        ScrollbarHovered.prototype.verticalHovered;
        /** @type {?|undefined} */
        ScrollbarHovered.prototype.horizontalHovered;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CssVariable = /** @class */ (function () {
        function CssVariable(sanitizer) {
            this.sanitizer = sanitizer;
        }
        /**
         * @param {?} size
         * @param {?} variableName
         * @return {?}
         */
        CssVariable.prototype.transform = /**
         * @param {?} size
         * @param {?} variableName
         * @return {?}
         */
        function (size, variableName) {
            if (size === null) {
                size = 0;
            }
            return this.sanitizer.bypassSecurityTrustStyle("--" + variableName + ": -" + size + "px");
        };
        CssVariable.decorators = [
            { type: core.Pipe, args: [{
                        name: 'cssVariable'
                    },] }
        ];
        /** @nocollapse */
        CssVariable.ctorParameters = function () { return [
            { type: platformBrowser.DomSanitizer }
        ]; };
        return CssVariable;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        CssVariable.prototype.sanitizer;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgAttr = /** @class */ (function () {
        function NgAttr(el) {
            this.el = el;
        }
        Object.defineProperty(NgAttr.prototype, "ngAttr", {
            set: /**
             * @param {?} attrs
             * @return {?}
             */
            function (attrs) {
                var e_1, _a;
                try {
                    for (var _b = __values(Object.entries(attrs)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                        ((/** @type {?} */ (this.el.nativeElement))).setAttribute(key, value);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            },
            enumerable: true,
            configurable: true
        });
        NgAttr.decorators = [
            { type: core.Directive, args: [{ selector: '[ngAttr]' },] }
        ];
        /** @nocollapse */
        NgAttr.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        NgAttr.propDecorators = {
            ngAttr: [{ type: core.Input }]
        };
        return NgAttr;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NgAttr.prototype.el;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Factory that initialize the ResizeObserver if available in the browser
     * Otherwise, it lazy-loads the ResizeObserver polyfill
     */
    var ResizeObserverFactory = /** @class */ (function () {
        function ResizeObserverFactory(document, platform) {
            this.resizeObserverSource = new rxjs.BehaviorSubject(null);
            this.resizeObserverLoader = this.resizeObserverSource.asObservable();
            if (platform.isBrowser) {
                /** @type {?} */
                var resizeObserverApi = document.defaultView.ResizeObserver
                    ? rxjs.of(document.defaultView.ResizeObserver)
                    : rxjs.from(import('@juggle/resize-observer')).pipe(operators.map((/**
                     * @param {?} module
                     * @return {?}
                     */
                    function (module) { return module.ResizeObserver; })), operators.catchError((/**
                     * @param {?} e
                     * @return {?}
                     */
                    function (e) {
                        console.log('Unable to load ResizeObserver polyfill', e);
                        return rxjs.EMPTY;
                    })));
                this.resizeObserverSource.next(resizeObserverApi);
            }
        }
        ResizeObserverFactory.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        ResizeObserverFactory.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: platform.Platform }
        ]; };
        /** @nocollapse */ ResizeObserverFactory.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function ResizeObserverFactory_Factory() { return new ResizeObserverFactory(core.ɵɵinject(common.DOCUMENT), core.ɵɵinject(platform.Platform)); }, token: ResizeObserverFactory, providedIn: "root" });
        return ResizeObserverFactory;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        ResizeObserverFactory.prototype.resizeObserverSource;
        /** @type {?} */
        ResizeObserverFactory.prototype.resizeObserverLoader;
    }
    var ResizeSensor = /** @class */ (function () {
        function ResizeSensor(zone, platform, resizeObserverFactory, scrollbar) {
            this.zone = zone;
            this.platform = platform;
            this.resizeObserverFactory = resizeObserverFactory;
            this.scrollbar = scrollbar;
            this._disabled = false;
            this._subscription = null;
            this.resizeSensor = new core.EventEmitter();
            if (!scrollbar) {
                throw new Error('[NgScrollbar Resize Sensor Directive]: Host element must be an NgScrollbar component.');
            }
        }
        Object.defineProperty(ResizeSensor.prototype, "debounce", {
            /** Debounce interval for emitting the changes. */
            get: /**
             * Debounce interval for emitting the changes.
             * @return {?}
             */
            function () {
                return this._debounce;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._debounce = coercion.coerceNumberProperty(value);
                this._subscribe();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResizeSensor.prototype, "disabled", {
            /** Whether ResizeObserver is disabled. */
            get: /**
             * Whether ResizeObserver is disabled.
             * @return {?}
             */
            function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._disabled ? this._unsubscribe() : this._subscribe();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ResizeSensor.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (!this._subscription && !this._disabled) {
                this._subscribe();
            }
        };
        /**
         * @return {?}
         */
        ResizeSensor.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._unsubscribe();
        };
        /**
         * @private
         * @param {?} ResizeObserver
         * @return {?}
         */
        ResizeSensor.prototype._createObserver = /**
         * @private
         * @param {?} ResizeObserver
         * @return {?}
         */
        function (ResizeObserver) {
            var _this = this;
            return new rxjs.Observable((/**
             * @param {?} observer
             * @return {?}
             */
            function (observer) {
                _this._resizeObserver = new ResizeObserver((/**
                 * @return {?}
                 */
                function () { return observer.next(); }));
                _this._resizeObserver.observe(_this.scrollbar.viewport.nativeElement);
                if (_this.scrollbar.viewport.contentWrapperElement) {
                    _this._resizeObserver.observe(_this.scrollbar.viewport.contentWrapperElement);
                }
            }));
        };
        /**
         * @private
         * @return {?}
         */
        ResizeSensor.prototype._subscribe = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this._unsubscribe();
            if (this.platform.isBrowser) {
                this.zone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    _this._subscription = _this.resizeObserverFactory.resizeObserverLoader.pipe(operators.switchMap((/**
                     * @param {?} moduleObservable
                     * @return {?}
                     */
                    function (moduleObservable) { return moduleObservable; })), operators.switchMap((/**
                     * @param {?} ResizeObserver
                     * @return {?}
                     */
                    function (ResizeObserver) {
                        if (ResizeObserver) {
                            /** @type {?} */
                            var stream = _this._createObserver(ResizeObserver);
                            return _this.debounce ? stream.pipe(operators.debounceTime(_this._debounce)) : stream;
                        }
                        else {
                            return rxjs.EMPTY;
                        }
                    }))).subscribe((/**
                     * @return {?}
                     */
                    function () { return _this.resizeSensor.emit(); }));
                }));
            }
        };
        /**
         * @private
         * @return {?}
         */
        ResizeSensor.prototype._unsubscribe = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._resizeObserver) {
                this._resizeObserver.disconnect();
            }
            if (this._subscription) {
                this._subscription.unsubscribe();
            }
        };
        ResizeSensor.decorators = [
            { type: core.Directive, args: [{ selector: '[resizeSensor]' },] }
        ];
        /** @nocollapse */
        ResizeSensor.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: platform.Platform },
            { type: ResizeObserverFactory },
            { type: NgScrollbar }
        ]; };
        ResizeSensor.propDecorators = {
            debounce: [{ type: core.Input, args: ['sensorDebounce',] }],
            disabled: [{ type: core.Input, args: ['sensorDisabled',] }],
            resizeSensor: [{ type: core.Output }]
        };
        return ResizeSensor;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype._debounce;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype._subscription;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype._resizeObserver;
        /** @type {?} */
        ResizeSensor.prototype.resizeSensor;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype.zone;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype.platform;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype.resizeObserverFactory;
        /**
         * @type {?}
         * @private
         */
        ResizeSensor.prototype.scrollbar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var   /**
     * @abstract
     */
    TrackAdapter = /** @class */ (function () {
        function TrackAdapter(cmp, trackElement, document) {
            this.cmp = cmp;
            this.trackElement = trackElement;
            this.document = document;
        }
        Object.defineProperty(TrackAdapter.prototype, "clicked", {
            // Stream that emits when the track element is clicked
            get: 
            // Stream that emits when the track element is clicked
            /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var mouseDown = rxjs.fromEvent(this.trackElement, 'mousedown', { passive: true }).pipe(stopPropagation(), preventSelection(this.document));
                /** @type {?} */
                var mouseup = rxjs.fromEvent(this.document, 'mouseup', { passive: true }).pipe(stopPropagation(), enableSelection(this.document), operators.switchMap((/**
                 * @return {?}
                 */
                function () { return rxjs.EMPTY; })));
                return rxjs.merge(mouseDown, mouseup);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TrackAdapter.prototype, "hovered", {
            // Stream that emits when the track element is hovered
            get: 
            // Stream that emits when the track element is hovered
            /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var mouseEnter = rxjs.fromEvent(this.trackElement, 'mouseenter', { passive: true }).pipe(stopPropagation(), operators.map((/**
                 * @return {?}
                 */
                function () { return true; })));
                /** @type {?} */
                var mouseLeave = rxjs.fromEvent(this.trackElement, 'mouseleave', { passive: true }).pipe(stopPropagation(), operators.map((/**
                 * @return {?}
                 */
                function () { return false; })));
                return rxjs.merge(mouseEnter, mouseLeave);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TrackAdapter.prototype, "clientRect", {
            // Get track client rect
            get: 
            // Get track client rect
            /**
             * @return {?}
             */
            function () {
                return this.trackElement.getBoundingClientRect();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Stream that emits when scrollbar track is clicked
         */
        /**
         * Stream that emits when scrollbar track is clicked
         * @param {?} e
         * @param {?} thumbSize
         * @param {?} scrollSize
         * @return {?}
         */
        TrackAdapter.prototype.onTrackClicked = /**
         * Stream that emits when scrollbar track is clicked
         * @param {?} e
         * @param {?} thumbSize
         * @param {?} scrollSize
         * @return {?}
         */
        function (e, thumbSize, scrollSize) {
            var _this = this;
            return rxjs.of(e).pipe(operators.pluck(this.pageProperty), 
            // Calculate scrollTo position
            operators.map((/**
             * @param {?} pageOffset
             * @return {?}
             */
            function (pageOffset) {
                /** @type {?} */
                var clickOffset = pageOffset - _this.offset;
                /** @type {?} */
                var offset = clickOffset - (thumbSize / 2);
                /** @type {?} */
                var ratio = offset / _this.size;
                return ratio * scrollSize;
            })), 
            // Smooth scroll to position
            operators.tap((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                _this.cmp.scrollTo(__assign({}, _this.mapToScrollToOption(value), { duration: coercion.coerceNumberProperty(_this.cmp.trackClickScrollDuration) }));
            })));
        };
        return TrackAdapter;
    }());
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        TrackAdapter.prototype.cmp;
        /**
         * @type {?}
         * @protected
         */
        TrackAdapter.prototype.trackElement;
        /**
         * @type {?}
         * @protected
         */
        TrackAdapter.prototype.document;
        /**
         * @abstract
         * @return {?}
         */
        TrackAdapter.prototype.pageProperty = function () { };
        /**
         * @abstract
         * @return {?}
         */
        TrackAdapter.prototype.size = function () { };
        /**
         * @abstract
         * @return {?}
         */
        TrackAdapter.prototype.offset = function () { };
        /**
         * @abstract
         * @protected
         * @param {?} value
         * @return {?}
         */
        TrackAdapter.prototype.mapToScrollToOption = function (value) { };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var ThumbAdapter = /** @class */ (function () {
        function ThumbAdapter(cmp, thumbElement, document) {
            this.cmp = cmp;
            this.thumbElement = thumbElement;
            this.document = document;
            // Stream that emits dragging state
            this._dragging = new rxjs.Subject();
            this.dragging = this._dragging.pipe(operators.distinctUntilChanged());
        }
        Object.defineProperty(ThumbAdapter.prototype, "trackMax", {
            get: /**
             * @return {?}
             */
            function () {
                return this.track.size - this.size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbAdapter.prototype, "clientRect", {
            // Get thumb client rect
            get: 
            // Get thumb client rect
            /**
             * @return {?}
             */
            function () {
                return this.thumbElement.getBoundingClientRect();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbAdapter.prototype, "clicked", {
            // Stream that emits when scrollbar thumb is clicked
            get: 
            // Stream that emits when scrollbar thumb is clicked
            /**
             * @return {?}
             */
            function () {
                return rxjs.fromEvent(this.thumbElement, 'mousedown', { passive: true }).pipe(stopPropagation());
            },
            enumerable: true,
            configurable: true
        });
        // Calculate and update thumb position and size
        // Calculate and update thumb position and size
        /**
         * @return {?}
         */
        ThumbAdapter.prototype.update = 
        // Calculate and update thumb position and size
        /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var size = calculateThumbSize(this.track.size, this.viewportScrollSize, (/** @type {?} */ (this.cmp.minThumbSize)));
            /** @type {?} */
            var position = calculateThumbPosition(this.viewportScrollOffset, this.viewportScrollMax, this.trackMax);
            rxjs.animationFrameScheduler.schedule((/**
             * @return {?}
             */
            function () { return _this.updateStyles(_this.handleDirection(position, _this.trackMax), size); }));
        };
        /**
         * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
         * This function is called by thumb drag event using viewport or scrollbar pointer events
         */
        /**
         * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
         * This function is called by thumb drag event using viewport or scrollbar pointer events
         * @param {?} event
         * @return {?}
         */
        ThumbAdapter.prototype.dragged = /**
         * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
         * This function is called by thumb drag event using viewport or scrollbar pointer events
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            /** @type {?} */
            var trackMaxStart;
            /** @type {?} */
            var scrollMaxStart;
            /** @type {?} */
            var dragStart = rxjs.of(event).pipe(preventSelection(this.document), operators.tap((/**
             * @return {?}
             */
            function () {
                // Capture scrollMax and trackMax once
                trackMaxStart = _this.trackMax;
                scrollMaxStart = _this.viewportScrollMax;
                _this.setDragging(true);
            })));
            /** @type {?} */
            var dragging = rxjs.fromEvent(this.document, 'mousemove', { capture: true, passive: true }).pipe(stopPropagation());
            /** @type {?} */
            var dragEnd = rxjs.fromEvent(this.document, 'mouseup', { capture: true }).pipe(stopPropagation(), enableSelection(this.document), operators.tap((/**
             * @return {?}
             */
            function () { return _this.setDragging(false); })));
            return dragStart.pipe(operators.pluck(this.pageProperty), operators.map((/**
             * @param {?} pageOffset
             * @return {?}
             */
            function (pageOffset) { return pageOffset - _this.dragStartOffset; })), operators.mergeMap((/**
             * @param {?} mouseDownOffset
             * @return {?}
             */
            function (mouseDownOffset) { return dragging.pipe(operators.pluck(_this.clientProperty), 
            // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).
            operators.map((/**
             * @param {?} mouseOffset
             * @return {?}
             */
            function (mouseOffset) { return mouseOffset - _this.track.offset; })), operators.map((/**
             * @param {?} offset
             * @return {?}
             */
            function (offset) { return scrollMaxStart * (offset - mouseDownOffset) / trackMaxStart; })), operators.map((/**
             * @param {?} position
             * @return {?}
             */
            function (position) { return _this.handleDrag(position, scrollMaxStart); })), operators.tap((/**
             * @param {?} position
             * @return {?}
             */
            function (position) { return _this.scrollTo(position); })), operators.takeUntil(dragEnd)); })));
        };
        ThumbAdapter.propDecorators = {
            track: [{ type: core.Input }],
            dragging: [{ type: core.Output }]
        };
        return ThumbAdapter;
    }());
    if (false) {
        /** @type {?} */
        ThumbAdapter.prototype.track;
        /**
         * @type {?}
         * @private
         */
        ThumbAdapter.prototype._dragging;
        /** @type {?} */
        ThumbAdapter.prototype.dragging;
        /**
         * @type {?}
         * @protected
         */
        ThumbAdapter.prototype.cmp;
        /**
         * @type {?}
         * @protected
         */
        ThumbAdapter.prototype.thumbElement;
        /**
         * @type {?}
         * @protected
         */
        ThumbAdapter.prototype.document;
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ThumbAdapter.prototype.pageProperty = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ThumbAdapter.prototype.clientProperty = function () { };
        /**
         * @abstract
         * @return {?}
         */
        ThumbAdapter.prototype.dragStartOffset = function () { };
        /**
         * @abstract
         * @return {?}
         */
        ThumbAdapter.prototype.size = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ThumbAdapter.prototype.viewportScrollSize = function () { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        ThumbAdapter.prototype.viewportScrollOffset = function () { };
        /**
         * @abstract
         * @return {?}
         */
        ThumbAdapter.prototype.viewportScrollMax = function () { };
        /**
         * @abstract
         * @protected
         * @param {?} value
         * @return {?}
         */
        ThumbAdapter.prototype.setDragging = function (value) { };
        /**
         * @abstract
         * @protected
         * @param {?} position
         * @return {?}
         */
        ThumbAdapter.prototype.scrollTo = function (position) { };
        /**
         * @abstract
         * @protected
         * @param {?} position
         * @param {?} size
         * @return {?}
         */
        ThumbAdapter.prototype.updateStyles = function (position, size) { };
        /**
         * @abstract
         * @protected
         * @param {?} position
         * @param {?=} scrollMax
         * @return {?}
         */
        ThumbAdapter.prototype.handleDrag = function (position, scrollMax) { };
        /**
         * @abstract
         * @protected
         * @param {?} position
         * @param {?=} scrollMax
         * @return {?}
         */
        ThumbAdapter.prototype.handleDirection = function (position, scrollMax) { };
    }
    /**
     * Calculate scrollbar thumb size
     * @param {?} trackSize
     * @param {?} contentSize
     * @param {?} minThumbSize
     * @return {?}
     */
    function calculateThumbSize(trackSize, contentSize, minThumbSize) {
        /** @type {?} */
        var scrollbarRatio = trackSize / contentSize;
        /** @type {?} */
        var thumbSize = scrollbarRatio * trackSize;
        return Math.max(~~thumbSize, minThumbSize);
    }
    /**
     * Calculate scrollbar thumb position
     * @param {?} scrollPosition
     * @param {?} scrollMax
     * @param {?} trackMax
     * @return {?}
     */
    function calculateThumbPosition(scrollPosition, scrollMax, trackMax) {
        return scrollPosition * trackMax / scrollMax;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ThumbXDirective = /** @class */ (function (_super) {
        __extends(ThumbXDirective, _super);
        function ThumbXDirective(cmp, element, document, dir) {
            var _this = _super.call(this, cmp, element.nativeElement, document) || this;
            _this.cmp = cmp;
            _this.element = element;
            _this.document = document;
            _this.dir = dir;
            return _this;
        }
        Object.defineProperty(ThumbXDirective.prototype, "clientProperty", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return 'clientX';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "pageProperty", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return 'pageX';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "viewportScrollSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.cmp.viewport.scrollWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "viewportScrollOffset", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.cmp.viewport.scrollLeft;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "viewportScrollMax", {
            get: /**
             * @return {?}
             */
            function () {
                return this.cmp.viewport.scrollMaxX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "dragStartOffset", {
            get: /**
             * @return {?}
             */
            function () {
                return this.clientRect.left;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbXDirective.prototype, "size", {
            get: /**
             * @return {?}
             */
            function () {
                return this.thumbElement.clientWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @param {?} position
         * @param {?} size
         * @return {?}
         */
        ThumbXDirective.prototype.updateStyles = /**
         * @protected
         * @param {?} position
         * @param {?} size
         * @return {?}
         */
        function (position, size) {
            this.thumbElement.style.width = size + "px";
            this.thumbElement.style.transform = "translate3d(" + position + "px, 0, 0)";
        };
        /**
         * @protected
         * @param {?} position
         * @param {?} scrollMax
         * @return {?}
         */
        ThumbXDirective.prototype.handleDrag = /**
         * @protected
         * @param {?} position
         * @param {?} scrollMax
         * @return {?}
         */
        function (position, scrollMax) {
            if (this.dir.value === 'rtl') {
                if (this.cmp.manager.rtlScrollAxisType === platform.RtlScrollAxisType.NEGATED) {
                    return position - scrollMax;
                }
                if (this.cmp.manager.rtlScrollAxisType === platform.RtlScrollAxisType.INVERTED) {
                    return scrollMax - position;
                }
                // Keeping this as a memo
                // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {
                //   return position;
                // }
            }
            return position;
        };
        /**
         * @protected
         * @param {?} position
         * @param {?} trackMax
         * @return {?}
         */
        ThumbXDirective.prototype.handleDirection = /**
         * @protected
         * @param {?} position
         * @param {?} trackMax
         * @return {?}
         */
        function (position, trackMax) {
            if (this.dir.value === 'rtl') {
                if (this.cmp.manager.rtlScrollAxisType === platform.RtlScrollAxisType.INVERTED) {
                    return -position;
                }
                if (this.cmp.manager.rtlScrollAxisType === platform.RtlScrollAxisType.NORMAL) {
                    return position - trackMax;
                }
                // Keeping this as a memo
                // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                //   return position;
                // }
            }
            return position;
        };
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        ThumbXDirective.prototype.setDragging = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.cmp.setDragging({ horizontalDragging: value });
        };
        /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        ThumbXDirective.prototype.scrollTo = /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        function (position) {
            this.cmp.viewport.scrollXTo(position);
        };
        ThumbXDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[scrollbarThumbX]' },] }
        ];
        /** @nocollapse */
        ThumbXDirective.ctorParameters = function () { return [
            { type: NgScrollbar },
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: bidi.Directionality }
        ]; };
        return ThumbXDirective;
    }(ThumbAdapter));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        ThumbXDirective.prototype.cmp;
        /**
         * @type {?}
         * @protected
         */
        ThumbXDirective.prototype.element;
        /**
         * @type {?}
         * @protected
         */
        ThumbXDirective.prototype.document;
        /**
         * @type {?}
         * @protected
         */
        ThumbXDirective.prototype.dir;
    }
    var ThumbYDirective = /** @class */ (function (_super) {
        __extends(ThumbYDirective, _super);
        function ThumbYDirective(cmp, element, document) {
            var _this = _super.call(this, cmp, element.nativeElement, document) || this;
            _this.cmp = cmp;
            _this.element = element;
            _this.document = document;
            return _this;
        }
        Object.defineProperty(ThumbYDirective.prototype, "pageProperty", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return 'pageY';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "viewportScrollSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.cmp.viewport.scrollHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "viewportScrollOffset", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.cmp.viewport.scrollTop;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "viewportScrollMax", {
            get: /**
             * @return {?}
             */
            function () {
                return this.cmp.viewport.scrollMaxY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "clientProperty", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return 'clientY';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "dragStartOffset", {
            get: /**
             * @return {?}
             */
            function () {
                return this.clientRect.top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThumbYDirective.prototype, "size", {
            get: /**
             * @return {?}
             */
            function () {
                return this.thumbElement.clientHeight;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @param {?} position
         * @param {?} size
         * @return {?}
         */
        ThumbYDirective.prototype.updateStyles = /**
         * @protected
         * @param {?} position
         * @param {?} size
         * @return {?}
         */
        function (position, size) {
            this.thumbElement.style.height = size + "px";
            this.thumbElement.style.transform = "translate3d(0px, " + position + "px, 0)";
        };
        /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        ThumbYDirective.prototype.handleDrag = /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        function (position) {
            return position;
        };
        /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        ThumbYDirective.prototype.handleDirection = /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        function (position) {
            return position;
        };
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        ThumbYDirective.prototype.setDragging = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.cmp.setDragging({ verticalDragging: value });
        };
        /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        ThumbYDirective.prototype.scrollTo = /**
         * @protected
         * @param {?} position
         * @return {?}
         */
        function (position) {
            this.cmp.viewport.scrollYTo(position);
        };
        ThumbYDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[scrollbarThumbY]' },] }
        ];
        /** @nocollapse */
        ThumbYDirective.ctorParameters = function () { return [
            { type: NgScrollbar },
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        return ThumbYDirective;
    }(ThumbAdapter));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        ThumbYDirective.prototype.cmp;
        /**
         * @type {?}
         * @protected
         */
        ThumbYDirective.prototype.element;
        /**
         * @type {?}
         * @protected
         */
        ThumbYDirective.prototype.document;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TrackXDirective = /** @class */ (function (_super) {
        __extends(TrackXDirective, _super);
        function TrackXDirective(cmp, trackElement, document) {
            var _this = _super.call(this, cmp, trackElement.nativeElement, document) || this;
            _this.cmp = cmp;
            _this.document = document;
            return _this;
        }
        Object.defineProperty(TrackXDirective.prototype, "pageProperty", {
            get: /**
             * @return {?}
             */
            function () {
                return 'pageX';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TrackXDirective.prototype, "offset", {
            get: /**
             * @return {?}
             */
            function () {
                return this.clientRect.left;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TrackXDirective.prototype, "size", {
            get: /**
             * @return {?}
             */
            function () {
                return this.trackElement.clientWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        TrackXDirective.prototype.mapToScrollToOption = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return { left: value };
        };
        TrackXDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[scrollbarTrackX]' },] }
        ];
        /** @nocollapse */
        TrackXDirective.ctorParameters = function () { return [
            { type: NgScrollbar },
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        return TrackXDirective;
    }(TrackAdapter));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        TrackXDirective.prototype.cmp;
        /**
         * @type {?}
         * @protected
         */
        TrackXDirective.prototype.document;
    }
    var TrackYDirective = /** @class */ (function (_super) {
        __extends(TrackYDirective, _super);
        function TrackYDirective(cmp, trackElement, document) {
            var _this = _super.call(this, cmp, trackElement.nativeElement, document) || this;
            _this.cmp = cmp;
            _this.document = document;
            return _this;
        }
        Object.defineProperty(TrackYDirective.prototype, "pageProperty", {
            get: /**
             * @return {?}
             */
            function () {
                return 'pageY';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TrackYDirective.prototype, "offset", {
            get: /**
             * @return {?}
             */
            function () {
                return this.clientRect.top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TrackYDirective.prototype, "size", {
            get: /**
             * @return {?}
             */
            function () {
                return this.trackElement.clientHeight;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        TrackYDirective.prototype.mapToScrollToOption = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return { top: value };
        };
        TrackYDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[scrollbarTrackY]' },] }
        ];
        /** @nocollapse */
        TrackYDirective.ctorParameters = function () { return [
            { type: NgScrollbar },
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        return TrackYDirective;
    }(TrackAdapter));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        TrackYDirective.prototype.cmp;
        /**
         * @type {?}
         * @protected
         */
        TrackYDirective.prototype.document;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var   /**
     * @abstract
     */
    Scrollbar = /** @class */ (function () {
        function Scrollbar(cmp, platform, document, zone) {
            this.cmp = cmp;
            this.platform = platform;
            this.document = document;
            this.zone = zone;
            // Stream that emits to unsubscribe from all streams
            this.destroyed = new rxjs.Subject();
        }
        /**
         * Activate scrollbar pointer events
         */
        /**
         * Activate scrollbar pointer events
         * @private
         * @return {?}
         */
        Scrollbar.prototype.activatePointerEvents = /**
         * Activate scrollbar pointer events
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // Stream that emits when scrollbar thumb is dragged
            /** @type {?} */
            var thumbDragEvent = rxjs.EMPTY;
            // Stream that emits when scrollbar track is clicked
            /** @type {?} */
            var trackClickEvent = rxjs.EMPTY;
            // Stream that emits when scrollbar track is hovered
            /** @type {?} */
            var trackHoveredEvent = rxjs.EMPTY;
            // Set the method used for the pointer events option
            if (this.cmp.pointerEventsMethod === 'viewport') {
                // Pointer events using the viewport
                this.viewportTrackClicked = new rxjs.Subject();
                this.viewportThumbClicked = new rxjs.Subject();
                // Activate the pointer events of the viewport directive
                this.cmp.viewport.activatePointerEvents(this.destroyed);
                // Set streams
                thumbDragEvent = this.viewportThumbClicked;
                trackClickEvent = this.viewportTrackClicked;
                trackHoveredEvent = this.cmp.viewport.hovered.pipe(
                // Check if track is hovered
                operators.map((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) { return isWithinBounds(e, _this.track.clientRect); })), operators.distinctUntilChanged(), 
                // Enable / disable text selection
                operators.tap((/**
                 * @param {?} hovered
                 * @return {?}
                 */
                function (hovered) { return _this.document.onselectstart = hovered ? (/**
                 * @return {?}
                 */
                function () { return false; }) : null; })));
                this.cmp.viewport.clicked.pipe(operators.tap((/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) {
                    if (e) {
                        if (isWithinBounds(e, _this.thumb.clientRect)) {
                            _this.viewportThumbClicked.next(e);
                        }
                        else if (isWithinBounds(e, _this.track.clientRect)) {
                            _this.cmp.setClicked(true);
                            _this.viewportTrackClicked.next(e);
                        }
                    }
                    else {
                        _this.cmp.setClicked(false);
                    }
                })), operators.takeUntil(this.destroyed)).subscribe();
            }
            else {
                // Pointer events method is using 'scrollbar'
                thumbDragEvent = this.thumb.clicked;
                trackClickEvent = this.track.clicked;
                trackHoveredEvent = this.track.hovered;
            }
            return rxjs.merge(
            // Activate scrollbar hovered event
            trackHoveredEvent.pipe(operators.tap((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return _this.setHovered(e); }))), 
            // Activate scrollbar thumb drag event
            thumbDragEvent.pipe(operators.switchMap((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return _this.thumb.dragged(e); }))), 
            // Activate scrollbar track click event
            trackClickEvent.pipe(operators.switchMap((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return _this.track.onTrackClicked(e, _this.thumb.size, _this.viewportScrollSize); }))));
        };
        /**
         * @return {?}
         */
        Scrollbar.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                // Activate pointer events on Desktop only
                if (!(_this.platform.IOS || _this.platform.ANDROID) && !_this.cmp.pointerEventsDisabled) {
                    _this.activatePointerEvents().pipe(operators.takeUntil(_this.destroyed)).subscribe();
                }
                // Stream that emits when host component is updated
                /** @type {?} */
                var updated = _this.cmp.updated.pipe(operators.tap((/**
                 * @return {?}
                 */
                function () { return _this.onUpdated(); })));
                // Update scrollbar thumb when viewport is scrolled and when scrollbar component is updated
                rxjs.merge(_this.cmp.scrolled, updated).pipe(operators.tap((/**
                 * @return {?}
                 */
                function () { return _this.thumb.update(); })), operators.takeUntil(_this.destroyed)).subscribe();
                // Initialize scrollbar
                rxjs.asyncScheduler.schedule((/**
                 * @return {?}
                 */
                function () { return _this.thumb.update(); }), 100);
            }));
        };
        /**
         * @return {?}
         */
        Scrollbar.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.destroyed.next();
            this.destroyed.complete();
            // Clean up viewport streams if used
            if (this.viewportThumbClicked && this.viewportTrackClicked) {
                this.viewportTrackClicked.complete();
                this.viewportThumbClicked.complete();
            }
        };
        return Scrollbar;
    }());
    if (false) {
        /** @type {?} */
        Scrollbar.prototype.thumb;
        /** @type {?} */
        Scrollbar.prototype.track;
        /**
         * @type {?}
         * @protected
         */
        Scrollbar.prototype.destroyed;
        /**
         * Viewport pointer events
         * The following streams are only activated when (pointerEventsMethod === 'viewport')
         * @type {?}
         * @protected
         */
        Scrollbar.prototype.viewportTrackClicked;
        /**
         * @type {?}
         * @protected
         */
        Scrollbar.prototype.viewportThumbClicked;
        /** @type {?} */
        Scrollbar.prototype.cmp;
        /**
         * @type {?}
         * @protected
         */
        Scrollbar.prototype.platform;
        /**
         * @type {?}
         * @protected
         */
        Scrollbar.prototype.document;
        /**
         * @type {?}
         * @protected
         */
        Scrollbar.prototype.zone;
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        Scrollbar.prototype.viewportScrollSize = function () { };
        /**
         * @abstract
         * @protected
         * @param {?} value
         * @return {?}
         */
        Scrollbar.prototype.setHovered = function (value) { };
        /**
         * @abstract
         * @protected
         * @return {?}
         */
        Scrollbar.prototype.onUpdated = function () { };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ScrollbarY = /** @class */ (function (_super) {
        __extends(ScrollbarY, _super);
        function ScrollbarY(cmp, platform, document, zone) {
            var _this = _super.call(this, cmp, platform, document, zone) || this;
            _this.cmp = cmp;
            _this.platform = platform;
            _this.document = document;
            _this.zone = zone;
            return _this;
        }
        Object.defineProperty(ScrollbarY.prototype, "viewportScrollSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.cmp.viewport.scrollHeight;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        ScrollbarY.prototype.setHovered = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.cmp.setHovered({ verticalHovered: value });
        };
        /**
         * @return {?}
         */
        ScrollbarY.prototype.onUpdated = /**
         * @return {?}
         */
        function () {
        };
        ScrollbarY.decorators = [
            { type: core.Component, args: [{
                        selector: 'scrollbar-y',
                        host: { '[class.scrollbar-control]': 'true' },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        template: "\n    <div scrollbarTrackY class=\"ng-scrollbar-track {{cmp.trackClass}}\">\n      <div scrollbarThumbY [track]=\"track\" class=\"ng-scrollbar-thumb {{cmp.thumbClass}}\"></div>\n    </div>\n  ",
                        styles: ["::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control{width:var(--vertical-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track{width:var(--vertical-scrollbar-size);height:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[verticalHovered=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[deactivated=false]>scrollbar-y.scrollbar-control{top:0;bottom:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr]>scrollbar-y.scrollbar-control{right:0;left:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertAll]>scrollbar-y.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertY]>scrollbar-y.scrollbar-control{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl]>scrollbar-y.scrollbar-control{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertAll]>scrollbar-y.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertY]>scrollbar-y.scrollbar-control{left:unset;right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all]>scrollbar-y.scrollbar-control[fit=true]{bottom:var(--scrollbar-total-size);top:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertAll]>scrollbar-y.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertX]>scrollbar-y.scrollbar-control[fit=true]{top:var(--scrollbar-total-size);bottom:0}"]
                    }] }
        ];
        /** @nocollapse */
        ScrollbarY.ctorParameters = function () { return [
            { type: NgScrollbar },
            { type: platform.Platform },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.NgZone }
        ]; };
        ScrollbarY.propDecorators = {
            track: [{ type: core.ViewChild, args: [TrackYDirective, { static: true },] }],
            thumb: [{ type: core.ViewChild, args: [ThumbYDirective, { static: true },] }]
        };
        return ScrollbarY;
    }(Scrollbar));
    if (false) {
        /** @type {?} */
        ScrollbarY.prototype.track;
        /** @type {?} */
        ScrollbarY.prototype.thumb;
        /** @type {?} */
        ScrollbarY.prototype.cmp;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarY.prototype.platform;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarY.prototype.document;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarY.prototype.zone;
    }
    var ScrollbarX = /** @class */ (function (_super) {
        __extends(ScrollbarX, _super);
        function ScrollbarX(el, cmp, platform, document, zone) {
            var _this = _super.call(this, cmp, platform, document, zone) || this;
            _this.el = el;
            _this.cmp = cmp;
            _this.platform = platform;
            _this.document = document;
            _this.zone = zone;
            return _this;
        }
        Object.defineProperty(ScrollbarX.prototype, "viewportScrollSize", {
            get: /**
             * @protected
             * @return {?}
             */
            function () {
                return this.cmp.viewport.scrollWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ScrollbarX.prototype, "thickness", {
            get: /**
             * @return {?}
             */
            function () {
                return this.el.nativeElement.clientHeight;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        ScrollbarX.prototype.setHovered = /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.cmp.setHovered({ horizontalHovered: value });
        };
        /**
         * @return {?}
         */
        ScrollbarX.prototype.onUpdated = /**
         * @return {?}
         */
        function () {
            // Auto-height: Set root component height to content height
            this.cmp.nativeElement.style.height = this.cmp.appearance === 'standard'
                ? this.cmp.viewport.contentHeight + this.thickness + "px"
                : this.cmp.viewport.contentHeight + "px";
        };
        ScrollbarX.decorators = [
            { type: core.Component, args: [{
                        selector: 'scrollbar-x',
                        host: { '[class.scrollbar-control]': 'true' },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        template: "\n    <div scrollbarTrackX class=\"ng-scrollbar-track {{cmp.trackClass}}\">\n      <div scrollbarThumbX [track]=\"track\" class=\"ng-scrollbar-thumb {{cmp.thumbClass}}\"></div>\n    </div>\n  ",
                        styles: ["::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control{height:var(--horizontal-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{width:0;height:100%}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[horizontalHovered=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[position=invertAll]>scrollbar-x.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[position=invertX]>scrollbar-x.scrollbar-control{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false]>scrollbar-x.scrollbar-control{left:0;right:0;bottom:0;top:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][position=invertAll]>scrollbar-x.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][position=invertX]>scrollbar-x.scrollbar-control{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertAll]>scrollbar-x.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertY]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertAll]>scrollbar-x.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertY]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}"]
                    }] }
        ];
        /** @nocollapse */
        ScrollbarX.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: NgScrollbar },
            { type: platform.Platform },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.NgZone }
        ]; };
        ScrollbarX.propDecorators = {
            track: [{ type: core.ViewChild, args: [TrackXDirective, { static: true },] }],
            thumb: [{ type: core.ViewChild, args: [ThumbXDirective, { static: true },] }]
        };
        return ScrollbarX;
    }(Scrollbar));
    if (false) {
        /** @type {?} */
        ScrollbarX.prototype.track;
        /** @type {?} */
        ScrollbarX.prototype.thumb;
        /**
         * @type {?}
         * @private
         */
        ScrollbarX.prototype.el;
        /** @type {?} */
        ScrollbarX.prototype.cmp;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarX.prototype.platform;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarX.prototype.document;
        /**
         * @type {?}
         * @protected
         */
        ScrollbarX.prototype.zone;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgScrollbarModule = /** @class */ (function () {
        function NgScrollbarModule() {
        }
        NgScrollbarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            bidi.BidiModule,
                            portal.PortalModule,
                            platform.PlatformModule,
                            smoothScroll.SmoothScrollModule
                        ],
                        declarations: [
                            NgScrollbar,
                            ScrollViewport,
                            CssVariable,
                            NgAttr,
                            ResizeSensor,
                            ThumbYDirective,
                            ThumbXDirective,
                            TrackXDirective,
                            TrackYDirective,
                            ScrollbarY,
                            ScrollbarX
                        ],
                        exports: [
                            NgScrollbar,
                            ScrollViewport
                        ]
                    },] }
        ];
        return NgScrollbarModule;
    }());

    exports.NG_SCROLLBAR_OPTIONS = NG_SCROLLBAR_OPTIONS;
    exports.NgScrollbar = NgScrollbar;
    exports.NgScrollbarModule = NgScrollbarModule;
    exports.ScrollViewport = ScrollViewport;
    exports.ScrollbarManager = ScrollbarManager;
    exports.ɵa = NativeScrollbarSizeFactory;
    exports.ɵb = CssVariable;
    exports.ɵc = NgAttr;
    exports.ɵd = ResizeObserverFactory;
    exports.ɵe = ResizeSensor;
    exports.ɵf = ThumbXDirective;
    exports.ɵg = ThumbYDirective;
    exports.ɵh = ThumbAdapter;
    exports.ɵi = TrackXDirective;
    exports.ɵj = TrackYDirective;
    exports.ɵk = TrackAdapter;
    exports.ɵl = ScrollbarY;
    exports.ɵm = ScrollbarX;
    exports.ɵn = Scrollbar;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-scrollbar.umd.js.map
