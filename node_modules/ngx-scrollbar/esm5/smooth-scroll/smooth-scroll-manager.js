/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Inject, Injectable, PLATFORM_ID, Optional } from '@angular/core';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { getRtlScrollAxisType, RtlScrollAxisType } from '@angular/cdk/platform';
import { fromEvent, merge, of, Observable, Subject, animationFrameScheduler } from 'rxjs';
import { expand, finalize, take, takeUntil, takeWhile } from 'rxjs/operators';
import BezierEasing from 'bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "./smooth-scroll.model";
// @dynamic
var SmoothScrollManager = /** @class */ (function () {
    function SmoothScrollManager(_document, _platform, customDefaultOptions) {
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = tslib_1.__assign({ duration: 468, easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            } }, customDefaultOptions);
    }
    Object.defineProperty(SmoothScrollManager.prototype, "_w", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._document.defaultView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SmoothScrollManager.prototype, "_now", {
        /**
         * Timing method
         */
        get: /**
         * Timing method
         * @private
         * @return {?}
         */
        function () {
            return this._w.performance && this._w.performance.now
                ? this._w.performance.now.bind(this._w.performance)
                : Date.now;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * changes scroll position inside an element
     */
    /**
     * changes scroll position inside an element
     * @private
     * @param {?} el
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    SmoothScrollManager.prototype._scrollElement = /**
     * changes scroll position inside an element
     * @private
     * @param {?} el
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    function (el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    };
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     * @private
     * @param {?} el
     * @param {?=} parent
     * @return {?}
     */
    SmoothScrollManager.prototype._getElement = /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     * @private
     * @param {?} el
     * @param {?=} parent
     * @return {?}
     */
    function (el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    };
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     * @private
     * @param {?} el
     * @return {?}
     */
    SmoothScrollManager.prototype._initSmoothScroll = /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     * @private
     * @param {?} el
     * @return {?}
     */
    function (el) {
        if (this._onGoingScrolls.has(el)) {
            (/** @type {?} */ (this._onGoingScrolls.get(el))).next();
        }
        return (/** @type {?} */ ((/** @type {?} */ (this._onGoingScrolls.set(el, new Subject()))).get(el)));
    };
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     * @private
     * @param {?} context
     * @param {?} destroyed
     * @param {?} resolve
     * @return {?}
     */
    SmoothScrollManager.prototype._isFinished = /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     * @private
     * @param {?} context
     * @param {?} destroyed
     * @param {?} resolve
     * @return {?}
     */
    function (context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    };
    /**
     * Terminates an ongoing smooth scroll
     */
    /**
     * Terminates an ongoing smooth scroll
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    SmoothScrollManager.prototype._interrupted = /**
     * Terminates an ongoing smooth scroll
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    function (el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    };
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    SmoothScrollManager.prototype._destroy = /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     * @private
     * @param {?} el
     * @param {?} destroyed
     * @return {?}
     */
    function (el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    };
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    /**
     * A function called recursively that, given a context, steps through scrolling
     * @private
     * @param {?} context
     * @return {?}
     */
    SmoothScrollManager.prototype._step = /**
     * A function called recursively that, given a context, steps through scrolling
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        var _this = this;
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            /** @type {?} */
            var elapsed = (_this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            /** @type {?} */
            var value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            _this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            animationFrameScheduler.schedule((/**
             * @return {?}
             */
            function () { return observer.next(context); }));
        }));
    };
    /**
     * @private
     * @param {?} el
     * @param {?} options
     * @return {?}
     */
    SmoothScrollManager.prototype._applyScrollToOptions = /**
     * @private
     * @param {?} el
     * @param {?} options
     * @return {?}
     */
    function (el, options) {
        var _this = this;
        if (!(/** @type {?} */ (options.duration))) {
            this._scrollElement(el, (/** @type {?} */ ((/** @type {?} */ (options)).left)), (/** @type {?} */ ((/** @type {?} */ (options)).top)));
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        /** @type {?} */
        var destroyed = this._initSmoothScroll(el);
        /** @type {?} */
        var context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: (/** @type {?} */ (options.duration)),
            easing: BezierEasing((/** @type {?} */ ((/** @type {?} */ (options.easing)).x1)), (/** @type {?} */ ((/** @type {?} */ (options.easing)).y1)), (/** @type {?} */ ((/** @type {?} */ (options.easing)).x2)), (/** @type {?} */ ((/** @type {?} */ (options.easing)).y2)))
        };
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        function (resolve) {
            // Scroll each step recursively
            of(null).pipe(expand((/**
             * @return {?}
             */
            function () { return _this._step(context).pipe(takeWhile((/**
             * @param {?} currContext
             * @return {?}
             */
            function (currContext) { return _this._isFinished(currContext, destroyed, resolve); }))); })), takeUntil(_this._interrupted(el, destroyed)), finalize((/**
             * @return {?}
             */
            function () { return _this._destroy(el, destroyed); }))).subscribe();
        }));
    };
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param options specified the offsets to scroll to.
     */
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param {?} scrollable element
     * @param {?} customOptions
     * @return {?}
     */
    SmoothScrollManager.prototype.scrollTo = /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param {?} scrollable element
     * @param {?} customOptions
     * @return {?}
     */
    function (scrollable, customOptions) {
        if (isPlatformBrowser(this._platform)) {
            /** @type {?} */
            var el = this._getElement(scrollable);
            /** @type {?} */
            var isRtl = getComputedStyle(el).direction === 'rtl';
            /** @type {?} */
            var rtlScrollAxisType = getRtlScrollAxisType();
            /** @type {?} */
            var options = tslib_1.__assign({}, ((/** @type {?} */ (this._defaultOptions))), customOptions, ((/** @type {?} */ ({
                // Rewrite start & end offsets as right or left offsets.
                left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
            }))));
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                ((/** @type {?} */ (options))).top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== RtlScrollAxisType.NORMAL) {
                if (options.left != null) {
                    ((/** @type {?} */ (options))).right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    ((/** @type {?} */ (options))).left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
        return Promise.resolve();
    };
    /**
     * Scroll to element by reference or selector
     */
    /**
     * Scroll to element by reference or selector
     * @param {?} scrollable
     * @param {?} target
     * @param {?} customOptions
     * @return {?}
     */
    SmoothScrollManager.prototype.scrollToElement = /**
     * Scroll to element by reference or selector
     * @param {?} scrollable
     * @param {?} target
     * @param {?} customOptions
     * @return {?}
     */
    function (scrollable, target, customOptions) {
        /** @type {?} */
        var scrollableEl = this._getElement(scrollable);
        /** @type {?} */
        var targetEl = this._getElement(target, scrollableEl);
        /** @type {?} */
        var options = tslib_1.__assign({}, customOptions, {
            left: targetEl.offsetLeft + (customOptions.left || 0),
            top: targetEl.offsetTop + (customOptions.top || 0)
        });
        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();
    };
    SmoothScrollManager.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    SmoothScrollManager.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SMOOTH_SCROLL_OPTIONS,] }] }
    ]; };
    /** @nocollapse */ SmoothScrollManager.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function SmoothScrollManager_Factory() { return new SmoothScrollManager(i0.ɵɵinject(i1.DOCUMENT), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i2.SMOOTH_SCROLL_OPTIONS, 8)); }, token: SmoothScrollManager, providedIn: "root" });
    return SmoothScrollManager;
}());
export { SmoothScrollManager };
if (false) {
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._defaultOptions;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._onGoingScrolls;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._document;
    /**
     * @type {?}
     * @private
     */
    SmoothScrollManager.prototype._platform;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXNjcm9sbGJhci9zbW9vdGgtc2Nyb2xsLyIsInNvdXJjZXMiOlsic21vb3RoLXNjcm9sbC1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFjLE1BQU0sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RixPQUFPLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRWhGLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzFGLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUUsT0FBTyxZQUFZLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFDTCxxQkFBcUIsRUFLdEIsTUFBTSx1QkFBdUIsQ0FBQzs7Ozs7QUFHL0I7SUEyQkUsNkJBQXNDLFNBQWMsRUFDWCxTQUFpQixFQUNILG9CQUEyQztRQUY1RCxjQUFTLEdBQVQsU0FBUyxDQUFLO1FBQ1gsY0FBUyxHQUFULFNBQVMsQ0FBUTs7Ozs7UUFoQmxELG9CQUFlLEdBQUcsSUFBSSxHQUFHLEVBQThCLENBQUM7UUFrQjlELElBQUksQ0FBQyxlQUFlLHNCQUNsQixRQUFRLEVBQUUsR0FBRyxFQUNiLE1BQU0sRUFBRTtnQkFDTixFQUFFLEVBQUUsSUFBSTtnQkFDUixFQUFFLEVBQUUsQ0FBQztnQkFDTCxFQUFFLEVBQUUsSUFBSTtnQkFDUixFQUFFLEVBQUUsQ0FBQzthQUNOLElBQ0Usb0JBQW9CLENBQ3hCLENBQUM7SUFDSixDQUFDO0lBMUJELHNCQUFZLG1DQUFFOzs7OztRQUFkO1lBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztRQUNwQyxDQUFDOzs7T0FBQTtJQUtELHNCQUFZLHFDQUFJO1FBSGhCOztXQUVHOzs7Ozs7UUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsR0FBRztnQkFDbkQsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUM7Z0JBQ25ELENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ2YsQ0FBQzs7O09BQUE7SUFpQkQ7O09BRUc7Ozs7Ozs7OztJQUNLLDRDQUFjOzs7Ozs7OztJQUF0QixVQUF1QixFQUFlLEVBQUUsQ0FBUyxFQUFFLENBQVM7UUFDMUQsRUFBRSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUM7UUFDbEIsRUFBRSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVEOztPQUVHOzs7Ozs7OztJQUNLLHlDQUFXOzs7Ozs7O0lBQW5CLFVBQW9CLEVBQXFDLEVBQUUsTUFBb0I7UUFDN0UsSUFBSSxPQUFPLEVBQUUsS0FBSyxRQUFRLEVBQUU7WUFDMUIsT0FBTyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3JEO1FBQ0QsT0FBTyxhQUFhLENBQWMsRUFBRSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOztPQUVHOzs7Ozs7O0lBQ0ssK0NBQWlCOzs7Ozs7SUFBekIsVUFBMEIsRUFBZTtRQUN2QyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ2hDLG1CQUFBLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDdEM7UUFDRCxPQUFPLG1CQUFBLG1CQUFBLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLE9BQU8sRUFBUSxDQUFDLEVBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQ7O09BRUc7Ozs7Ozs7OztJQUNLLHlDQUFXOzs7Ozs7OztJQUFuQixVQUFvQixPQUF5QixFQUFFLFNBQXdCLEVBQUUsT0FBbUI7UUFDMUYsSUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLE9BQU8sQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPLENBQUMsQ0FBQyxFQUFFO1lBQ3BFLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDakIsT0FBTyxFQUFFLENBQUM7UUFDVixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRzs7Ozs7Ozs7SUFDSywwQ0FBWTs7Ozs7OztJQUFwQixVQUFxQixFQUFlLEVBQUUsU0FBd0I7UUFDNUQsT0FBTyxLQUFLLENBQ1YsU0FBUyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUN4RCxTQUFTLENBQUMsRUFBRSxFQUFFLFdBQVcsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQzVELFNBQVMsQ0FDVixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBRUQ7O09BRUc7Ozs7Ozs7O0lBQ0ssc0NBQVE7Ozs7Ozs7SUFBaEIsVUFBaUIsRUFBZSxFQUFFLFNBQXdCO1FBQ3hELFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7O09BRUc7Ozs7Ozs7SUFDSyxtQ0FBSzs7Ozs7O0lBQWIsVUFBYyxPQUF5QjtRQUF2QyxpQkFpQkM7UUFoQkMsT0FBTyxJQUFJLFVBQVU7Ozs7UUFBQyxVQUFBLFFBQVE7O2dCQUN4QixPQUFPLEdBQUcsQ0FBQyxLQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxRQUFRO1lBRWxFLHNDQUFzQztZQUN0QyxPQUFPLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7OztnQkFHOUIsS0FBSyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO1lBRXJDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQztZQUN6RSxPQUFPLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUM7WUFFekUsS0FBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzVFLHNCQUFzQjtZQUN0Qix1QkFBdUIsQ0FBQyxRQUFROzs7WUFBQyxjQUFNLE9BQUEsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBdEIsQ0FBc0IsRUFBQyxDQUFDO1FBQ2pFLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7OztJQUVPLG1EQUFxQjs7Ozs7O0lBQTdCLFVBQThCLEVBQWUsRUFBRSxPQUE4QjtRQUE3RSxpQkE4QkM7UUE3QkMsSUFBSSxDQUFDLG1CQUFBLE9BQU8sQ0FBQyxRQUFRLEVBQUMsRUFBRTtZQUN0QixJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxtQkFBQSxtQkFBQSxPQUFPLEVBQUMsQ0FBQyxJQUFJLEVBQUMsRUFBRSxtQkFBQSxtQkFBQSxPQUFPLEVBQUMsQ0FBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO1lBQ3ZELE9BQU8sT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQzFCOzs7WUFHSyxTQUFTLEdBQWtCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUM7O1lBRXJELE9BQU8sR0FBcUI7WUFDaEMsVUFBVSxFQUFFLEVBQUU7WUFDZCxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRTtZQUN0QixNQUFNLEVBQUUsRUFBRSxDQUFDLFVBQVU7WUFDckIsTUFBTSxFQUFFLEVBQUUsQ0FBQyxTQUFTO1lBQ3BCLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJO1lBQ3hELENBQUMsRUFBRSxPQUFPLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHO1lBQ3JELFFBQVEsRUFBRSxtQkFBQSxPQUFPLENBQUMsUUFBUSxFQUFDO1lBQzNCLE1BQU0sRUFBRSxZQUFZLENBQUMsbUJBQUEsbUJBQUEsT0FBTyxDQUFDLE1BQU0sRUFBQyxDQUFDLEVBQUUsRUFBQyxFQUFFLG1CQUFBLG1CQUFBLE9BQU8sQ0FBQyxNQUFNLEVBQUMsQ0FBQyxFQUFFLEVBQUMsRUFBRSxtQkFBQSxtQkFBQSxPQUFPLENBQUMsTUFBTSxFQUFDLENBQUMsRUFBRSxFQUFDLEVBQUUsbUJBQUEsbUJBQUEsT0FBTyxDQUFDLE1BQU0sRUFBQyxDQUFDLEVBQUUsRUFBQyxDQUFDO1NBQ3pHO1FBRUQsT0FBTyxJQUFJLE9BQU87Ozs7UUFBQyxVQUFBLE9BQU87WUFDeEIsK0JBQStCO1lBQy9CLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQ1gsTUFBTTs7O1lBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUNuQyxTQUFTOzs7O1lBQUMsVUFBQyxXQUE2QixJQUFLLE9BQUEsS0FBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxFQUFqRCxDQUFpRCxFQUFDLENBQ2hHLEVBRlksQ0FFWixFQUFDLEVBQ0YsU0FBUyxDQUFDLEtBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQzNDLFFBQVE7OztZQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsRUFBNUIsQ0FBNEIsRUFBQyxDQUM3QyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2hCLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQztJQUdEOzs7Ozs7OztPQVFHOzs7Ozs7Ozs7OztJQUNILHNDQUFROzs7Ozs7Ozs7O0lBQVIsVUFBUyxVQUErQixFQUFFLGFBQW9DO1FBQzVFLElBQUksaUJBQWlCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFOztnQkFDL0IsRUFBRSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDOztnQkFDakMsS0FBSyxHQUFHLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsS0FBSyxLQUFLOztnQkFDaEQsaUJBQWlCLEdBQUcsb0JBQW9CLEVBQUU7O2dCQUUxQyxPQUFPLHdCQUNSLENBQUMsbUJBQUEsSUFBSSxDQUFDLGVBQWUsRUFBNEIsQ0FBQyxFQUNsRCxhQUFhLEVBQ2IsQ0FBQyxtQkFBQTs7Z0JBRUYsSUFBSSxFQUFFLGFBQWEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSTtnQkFDekcsS0FBSyxFQUFFLGFBQWEsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSzthQUM3RyxFQUE0QixDQUFDLENBQy9CO1lBRUQsNkNBQTZDO1lBQzdDLElBQUksT0FBTyxDQUFDLE1BQU0sSUFBSSxJQUFJLEVBQUU7Z0JBQzFCLENBQUMsbUJBQUEsT0FBTyxFQUE0QixDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO2FBQ2hHO1lBRUQsNkNBQTZDO1lBQzdDLElBQUksS0FBSyxJQUFJLGlCQUFpQixLQUFLLGlCQUFpQixDQUFDLE1BQU0sRUFBRTtnQkFDM0QsSUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksRUFBRTtvQkFDeEIsQ0FBQyxtQkFBQSxPQUFPLEVBQTRCLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7aUJBQzlGO2dCQUVELElBQUksaUJBQWlCLEtBQUssaUJBQWlCLENBQUMsUUFBUSxFQUFFO29CQUNwRCxPQUFPLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7aUJBQzlCO3FCQUFNLElBQUksaUJBQWlCLEtBQUssaUJBQWlCLENBQUMsT0FBTyxFQUFFO29CQUMxRCxPQUFPLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztpQkFDL0Q7YUFDRjtpQkFBTTtnQkFDTCxJQUFJLE9BQU8sQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO29CQUN6QixDQUFDLG1CQUFBLE9BQU8sRUFBNEIsQ0FBQyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztpQkFDOUY7YUFDRjtZQUNELE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztTQUNoRDtRQUNELE9BQU8sT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7T0FFRzs7Ozs7Ozs7SUFDSCw2Q0FBZTs7Ozs7OztJQUFmLFVBQWdCLFVBQStCLEVBQUUsTUFBMkIsRUFBRSxhQUFpRDs7WUFDdkgsWUFBWSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDOztZQUMzQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDOztZQUNqRCxPQUFPLHdCQUNSLGFBQWEsRUFDYjtZQUNELElBQUksRUFBRSxRQUFRLENBQUMsVUFBVSxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7WUFDckQsR0FBRyxFQUFFLFFBQVEsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxhQUFhLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztTQUNuRCxDQUNGO1FBQ0QsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDN0UsQ0FBQzs7Z0JBN05GLFVBQVUsU0FBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7Ozs7Z0RBeUJjLE1BQU0sU0FBQyxRQUFROzZDQUNmLE1BQU0sU0FBQyxXQUFXO2dEQUNsQixRQUFRLFlBQUksTUFBTSxTQUFDLHFCQUFxQjs7OzhCQTlDdkQ7Q0ErT0MsQUE5TkQsSUE4TkM7U0EzTlksbUJBQW1COzs7Ozs7SUFHOUIsOENBQStDOzs7OztJQU0vQyw4Q0FBZ0U7Ozs7O0lBZXBELHdDQUF3Qzs7Ozs7SUFDeEMsd0NBQThDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RhYmxlLCBQTEFURk9STV9JRCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRE9DVU1FTlQsIGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgY29lcmNlRWxlbWVudCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XHJcbmltcG9ydCB7IGdldFJ0bFNjcm9sbEF4aXNUeXBlLCBSdGxTY3JvbGxBeGlzVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XHJcbmltcG9ydCB7IF9Cb3R0b20sIF9MZWZ0LCBfUmlnaHQsIF9Ub3AsIF9XaXRob3V0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XHJcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIG9mLCBPYnNlcnZhYmxlLCBTdWJqZWN0LCBhbmltYXRpb25GcmFtZVNjaGVkdWxlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBleHBhbmQsIGZpbmFsaXplLCB0YWtlLCB0YWtlVW50aWwsIHRha2VXaGlsZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IEJlemllckVhc2luZyBmcm9tICdiZXppZXItZWFzaW5nJztcclxuaW1wb3J0IHtcclxuICBTTU9PVEhfU0NST0xMX09QVElPTlMsXHJcbiAgU21vb3RoU2Nyb2xsRWxlbWVudCxcclxuICBTbW9vdGhTY3JvbGxPcHRpb25zLFxyXG4gIFNtb290aFNjcm9sbFN0ZXAsXHJcbiAgU21vb3RoU2Nyb2xsVG9PcHRpb25zXHJcbn0gZnJvbSAnLi9zbW9vdGgtc2Nyb2xsLm1vZGVsJztcclxuXHJcbi8vIEBkeW5hbWljXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIFNtb290aFNjcm9sbE1hbmFnZXIge1xyXG5cclxuICAvLyBEZWZhdWx0IG9wdGlvbnNcclxuICBwcml2YXRlIF9kZWZhdWx0T3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zO1xyXG5cclxuICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgb25nb2luZyBTbW9vdGhTY3JvbGwgZnVuY3Rpb25zIHNvIHRoZXkgY2FuIGJlIGhhbmRsZWQgaW4gY2FzZSBvZiBkdXBsaWNhdGlvbi5cclxuICAvLyBFYWNoIHNjcm9sbGVkIGVsZW1lbnQgZ2V0cyBhIGRlc3Ryb3llciBzdHJlYW0gd2hpY2ggZ2V0cyBkZWxldGVkIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGNvbXBsZXRlcy5cclxuICAvLyBQdXJwb3NlOiBJZiB1c2VyIGNhbGxlZCBhIHNjcm9sbCBmdW5jdGlvbiBhZ2FpbiBvbiB0aGUgc2FtZSBlbGVtZW50IGJlZm9yZSB0aGUgc2Nyb2xscyBjb21wbGV0ZXMsXHJcbiAgLy8gaXQgY2FuY2VscyB0aGUgb25nb2luZyBzY3JvbGwgYW5kIHN0YXJ0cyBhIG5ldyBvbmVcclxuICBwcml2YXRlIF9vbkdvaW5nU2Nyb2xscyA9IG5ldyBNYXA8SFRNTEVsZW1lbnQsIFN1YmplY3Q8dm9pZD4+KCk7XHJcblxyXG4gIHByaXZhdGUgZ2V0IF93KCk6IGFueSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaW1pbmcgbWV0aG9kXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXQgX25vdygpIHtcclxuICAgIHJldHVybiB0aGlzLl93LnBlcmZvcm1hbmNlICYmIHRoaXMuX3cucGVyZm9ybWFuY2Uubm93XHJcbiAgICAgID8gdGhpcy5fdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh0aGlzLl93LnBlcmZvcm1hbmNlKVxyXG4gICAgICA6IERhdGUubm93O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSxcclxuICAgICAgICAgICAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIF9wbGF0Zm9ybTogb2JqZWN0LFxyXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoU01PT1RIX1NDUk9MTF9PUFRJT05TKSBjdXN0b21EZWZhdWx0T3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKSB7XHJcbiAgICB0aGlzLl9kZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgZHVyYXRpb246IDQ2OCxcclxuICAgICAgZWFzaW5nOiB7XHJcbiAgICAgICAgeDE6IDAuNDIsXHJcbiAgICAgICAgeTE6IDAsXHJcbiAgICAgICAgeDI6IDAuNTgsXHJcbiAgICAgICAgeTI6IDFcclxuICAgICAgfSxcclxuICAgICAgLi4uY3VzdG9tRGVmYXVsdE9wdGlvbnMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY2hhbmdlcyBzY3JvbGwgcG9zaXRpb24gaW5zaWRlIGFuIGVsZW1lbnRcclxuICAgKi9cclxuICBwcml2YXRlIF9zY3JvbGxFbGVtZW50KGVsOiBIVE1MRWxlbWVudCwgeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGVsLnNjcm9sbExlZnQgPSB4O1xyXG4gICAgZWwuc2Nyb2xsVG9wID0geTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgYSBnaXZlbiBwYXJhbWV0ZXIgb2YgdHlwZSBIVE1MRWxlbWVudCwgRWxlbWVudFJlZiBvciBzZWxlY3RvclxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldEVsZW1lbnQoZWw6IEhUTUxFbGVtZW50IHwgRWxlbWVudFJlZiB8IHN0cmluZywgcGFyZW50PzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudCB7XHJcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gKHBhcmVudCB8fCB0aGlzLl9kb2N1bWVudCkucXVlcnlTZWxlY3RvcihlbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29lcmNlRWxlbWVudDxIVE1MRWxlbWVudD4oZWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgYSBkZXN0cm95ZXIgc3RyZWFtLCByZS1pbml0aWFsaXplcyBpdCBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIHNjcm9sbGVkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaW5pdFNtb290aFNjcm9sbChlbDogSFRNTEVsZW1lbnQpOiBTdWJqZWN0PHZvaWQ+IHtcclxuICAgIGlmICh0aGlzLl9vbkdvaW5nU2Nyb2xscy5oYXMoZWwpKSB7XHJcbiAgICAgIHRoaXMuX29uR29pbmdTY3JvbGxzLmdldChlbCkhLm5leHQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9vbkdvaW5nU2Nyb2xscy5zZXQoZWwsIG5ldyBTdWJqZWN0PHZvaWQ+KCkpIS5nZXQoZWwpITtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBzbW9vdGggc2Nyb2xsIGhhcyByZWFjaGVkLCBjbGVhbnMgdXAgdGhlIHNtb290aCBzY3JvbGwgc3RyZWFtIGFuZCByZXNvbHZlcyBpdHMgcHJvbWlzZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2lzRmluaXNoZWQoY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCwgZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+LCByZXNvbHZlOiAoKSA9PiB2b2lkKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoY29udGV4dC5jdXJyZW50WCAhPT0gY29udGV4dC54IHx8IGNvbnRleHQuY3VycmVudFkgIT09IGNvbnRleHQueSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3llZC5uZXh0KCk7XHJcbiAgICByZXNvbHZlKCk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXJtaW5hdGVzIGFuIG9uZ29pbmcgc21vb3RoIHNjcm9sbFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2ludGVycnVwdGVkKGVsOiBIVE1MRWxlbWVudCwgZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIHJldHVybiBtZXJnZShcclxuICAgICAgZnJvbUV2ZW50KGVsLCAnd2hlZWwnLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSksXHJcbiAgICAgIGZyb21FdmVudChlbCwgJ3RvdWNobW92ZScsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KSxcclxuICAgICAgZGVzdHJveWVkXHJcbiAgICApLnBpcGUodGFrZSgxKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGVzIHRoZSBkZXN0cm95ZXIgZnVuY3Rpb24sIHJ1bnMgaWYgdGhlIHNtb290aCBzY3JvbGwgaGFzIGZpbmlzaGVkIG9yIGludGVycnVwdGVkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZGVzdHJveShlbDogSFRNTEVsZW1lbnQsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IHZvaWQge1xyXG4gICAgZGVzdHJveWVkLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLl9vbkdvaW5nU2Nyb2xscy5kZWxldGUoZWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBmdW5jdGlvbiBjYWxsZWQgcmVjdXJzaXZlbHkgdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xyXG4gICAqL1xyXG4gIHByaXZhdGUgX3N0ZXAoY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCk6IE9ic2VydmFibGU8U21vb3RoU2Nyb2xsU3RlcD4ge1xyXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcclxuICAgICAgbGV0IGVsYXBzZWQgPSAodGhpcy5fbm93KCkgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyBjb250ZXh0LmR1cmF0aW9uO1xyXG5cclxuICAgICAgLy8gYXZvaWQgZWxhcHNlZCB0aW1lcyBoaWdoZXIgdGhhbiBvbmVcclxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XHJcblxyXG4gICAgICAvLyBhcHBseSBlYXNpbmcgdG8gZWxhcHNlZCB0aW1lXHJcbiAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dC5lYXNpbmcoZWxhcHNlZCk7XHJcblxyXG4gICAgICBjb250ZXh0LmN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XHJcbiAgICAgIGNvbnRleHQuY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcclxuXHJcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQoY29udGV4dC5zY3JvbGxhYmxlLCBjb250ZXh0LmN1cnJlbnRYLCBjb250ZXh0LmN1cnJlbnRZKTtcclxuICAgICAgLy8gUHJvY2VlZCB0byB0aGUgc3RlcFxyXG4gICAgICBhbmltYXRpb25GcmFtZVNjaGVkdWxlci5zY2hlZHVsZSgoKSA9PiBvYnNlcnZlci5uZXh0KGNvbnRleHQpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfYXBwbHlTY3JvbGxUb09wdGlvbnMoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghb3B0aW9ucy5kdXJhdGlvbiEpIHtcclxuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudChlbCwgb3B0aW9ucyEubGVmdCEsIG9wdGlvbnMhLnRvcCEpO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBhIGRlc3Ryb3llciBzdHJlYW0sIHJlaW5pdGlhbGl6ZSBpdCBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIHNjcm9sbGVkXHJcbiAgICBjb25zdCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4gPSB0aGlzLl9pbml0U21vb3RoU2Nyb2xsKGVsKTtcclxuXHJcbiAgICBjb25zdCBjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwID0ge1xyXG4gICAgICBzY3JvbGxhYmxlOiBlbCxcclxuICAgICAgc3RhcnRUaW1lOiB0aGlzLl9ub3coKSxcclxuICAgICAgc3RhcnRYOiBlbC5zY3JvbGxMZWZ0LFxyXG4gICAgICBzdGFydFk6IGVsLnNjcm9sbFRvcCxcclxuICAgICAgeDogb3B0aW9ucy5sZWZ0ID09IG51bGwgPyBlbC5zY3JvbGxMZWZ0IDogfn5vcHRpb25zLmxlZnQsXHJcbiAgICAgIHk6IG9wdGlvbnMudG9wID09IG51bGwgPyBlbC5zY3JvbGxUb3AgOiB+fm9wdGlvbnMudG9wLFxyXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbiEsXHJcbiAgICAgIGVhc2luZzogQmV6aWVyRWFzaW5nKG9wdGlvbnMuZWFzaW5nIS54MSEsIG9wdGlvbnMuZWFzaW5nIS55MSEsIG9wdGlvbnMuZWFzaW5nIS54MiEsIG9wdGlvbnMuZWFzaW5nIS55MiEpXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgLy8gU2Nyb2xsIGVhY2ggc3RlcCByZWN1cnNpdmVseVxyXG4gICAgICBvZihudWxsKS5waXBlKFxyXG4gICAgICAgIGV4cGFuZCgoKSA9PiB0aGlzLl9zdGVwKGNvbnRleHQpLnBpcGUoXHJcbiAgICAgICAgICB0YWtlV2hpbGUoKGN1cnJDb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwKSA9PiB0aGlzLl9pc0ZpbmlzaGVkKGN1cnJDb250ZXh0LCBkZXN0cm95ZWQsIHJlc29sdmUpKVxyXG4gICAgICAgICkpLFxyXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9pbnRlcnJ1cHRlZChlbCwgZGVzdHJveWVkKSksXHJcbiAgICAgICAgZmluYWxpemUoKCkgPT4gdGhpcy5fZGVzdHJveShlbCwgZGVzdHJveWVkKSlcclxuICAgICAgKS5zdWJzY3JpYmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBvZmZzZXRzLiBUaGlzIGlzIGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNjcm9sbFRvXHJcbiAgICogbWV0aG9kLCBzaW5jZSBicm93c2VycyBhcmUgbm90IGNvbnNpc3RlbnQgYWJvdXQgd2hhdCBzY3JvbGxMZWZ0IG1lYW5zIGluIFJUTC4gRm9yIHRoaXMgbWV0aG9kXHJcbiAgICogbGVmdCBhbmQgcmlnaHQgYWx3YXlzIHJlZmVyIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyIGlycmVzcGVjdGl2ZVxyXG4gICAqIG9mIHRoZSBsYXlvdXQgZGlyZWN0aW9uLiBzdGFydCBhbmQgZW5kIHJlZmVyIHRvIGxlZnQgYW5kIHJpZ2h0IGluIGFuIExUUiBjb250ZXh0IGFuZCB2aWNlLXZlcnNhXHJcbiAgICogaW4gYW4gUlRMIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHNjcm9sbGFibGUgZWxlbWVudFxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHNwZWNpZmllZCB0aGUgb2Zmc2V0cyB0byBzY3JvbGwgdG8uXHJcbiAgICovXHJcbiAgc2Nyb2xsVG8oc2Nyb2xsYWJsZTogU21vb3RoU2Nyb2xsRWxlbWVudCwgY3VzdG9tT3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm0pKSB7XHJcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5fZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcclxuICAgICAgY29uc3QgaXNSdGwgPSBnZXRDb21wdXRlZFN0eWxlKGVsKS5kaXJlY3Rpb24gPT09ICdydGwnO1xyXG4gICAgICBjb25zdCBydGxTY3JvbGxBeGlzVHlwZSA9IGdldFJ0bFNjcm9sbEF4aXNUeXBlKCk7XHJcblxyXG4gICAgICBjb25zdCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XHJcbiAgICAgICAgLi4uKHRoaXMuX2RlZmF1bHRPcHRpb25zIGFzIF9XaXRob3V0PF9Cb3R0b20gJiBfVG9wPiksXHJcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcclxuICAgICAgICAuLi4oe1xyXG4gICAgICAgICAgLy8gUmV3cml0ZSBzdGFydCAmIGVuZCBvZmZzZXRzIGFzIHJpZ2h0IG9yIGxlZnQgb2Zmc2V0cy5cclxuICAgICAgICAgIGxlZnQ6IGN1c3RvbU9wdGlvbnMubGVmdCA9PSBudWxsID8gKGlzUnRsID8gY3VzdG9tT3B0aW9ucy5lbmQgOiBjdXN0b21PcHRpb25zLnN0YXJ0KSA6IGN1c3RvbU9wdGlvbnMubGVmdCxcclxuICAgICAgICAgIHJpZ2h0OiBjdXN0b21PcHRpb25zLnJpZ2h0ID09IG51bGwgPyAoaXNSdGwgPyBjdXN0b21PcHRpb25zLnN0YXJ0IDogY3VzdG9tT3B0aW9ucy5lbmQpIDogY3VzdG9tT3B0aW9ucy5yaWdodFxyXG4gICAgICAgIH0gYXMgX1dpdGhvdXQ8X0JvdHRvbSAmIF9Ub3A+KVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gUmV3cml0ZSB0aGUgYm90dG9tIG9mZnNldCBhcyBhIHRvcCBvZmZzZXQuXHJcbiAgICAgIGlmIChvcHRpb25zLmJvdHRvbSAhPSBudWxsKSB7XHJcbiAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X0JvdHRvbT4gJiBfVG9wKS50b3AgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQgLSBvcHRpb25zLmJvdHRvbTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmV3cml0ZSB0aGUgcmlnaHQgb2Zmc2V0IGFzIGEgbGVmdCBvZmZzZXQuXHJcbiAgICAgIGlmIChpc1J0bCAmJiBydGxTY3JvbGxBeGlzVHlwZSAhPT0gUnRsU2Nyb2xsQXhpc1R5cGUuTk9STUFMKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfTGVmdD4gJiBfUmlnaHQpLnJpZ2h0ID0gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIG9wdGlvbnMubGVmdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuSU5WRVJURUQpIHtcclxuICAgICAgICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCkge1xyXG4gICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5yaWdodCA/IC1vcHRpb25zLnJpZ2h0IDogb3B0aW9ucy5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X1JpZ2h0PiAmIF9MZWZ0KS5sZWZ0ID0gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIG9wdGlvbnMucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVNjcm9sbFRvT3B0aW9ucyhlbCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGwgdG8gZWxlbWVudCBieSByZWZlcmVuY2Ugb3Igc2VsZWN0b3JcclxuICAgKi9cclxuICBzY3JvbGxUb0VsZW1lbnQoc2Nyb2xsYWJsZTogU21vb3RoU2Nyb2xsRWxlbWVudCwgdGFyZ2V0OiBTbW9vdGhTY3JvbGxFbGVtZW50LCBjdXN0b21PcHRpb25zOiBTbW9vdGhTY3JvbGxPcHRpb25zICYgX1RvcCAmIF9MZWZ0KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBzY3JvbGxhYmxlRWwgPSB0aGlzLl9nZXRFbGVtZW50KHNjcm9sbGFibGUpO1xyXG4gICAgY29uc3QgdGFyZ2V0RWwgPSB0aGlzLl9nZXRFbGVtZW50KHRhcmdldCwgc2Nyb2xsYWJsZUVsKTtcclxuICAgIGNvbnN0IG9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyA9IHtcclxuICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcclxuICAgICAgLi4ue1xyXG4gICAgICAgIGxlZnQ6IHRhcmdldEVsLm9mZnNldExlZnQgKyAoY3VzdG9tT3B0aW9ucy5sZWZ0IHx8IDApLFxyXG4gICAgICAgIHRvcDogdGFyZ2V0RWwub2Zmc2V0VG9wICsgKGN1c3RvbU9wdGlvbnMudG9wIHx8IDApXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gdGFyZ2V0RWwgPyB0aGlzLnNjcm9sbFRvKHNjcm9sbGFibGVFbCwgb3B0aW9ucykgOiBQcm9taXNlLnJlc29sdmUoKTtcclxuICB9XHJcbn1cclxuIl19