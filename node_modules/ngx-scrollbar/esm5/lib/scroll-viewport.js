/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Inject, ElementRef } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { fromEvent, merge, Observable } from 'rxjs';
import { map, switchMap, takeUntil, tap } from 'rxjs/operators';
import { stopPropagation } from './scrollbar/common';
var ScrollViewport = /** @class */ (function () {
    function ScrollViewport(viewPort, document) {
        this.viewPort = viewPort;
        this.document = document;
        this.nativeElement = viewPort.nativeElement;
    }
    Object.defineProperty(ScrollViewport.prototype, "clientHeight", {
        // Get viewport size, clientHeight or clientWidth
        get: 
        // Get viewport size, clientHeight or clientWidth
        /**
         * @return {?}
         */
        function () {
            return this.nativeElement.clientHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "clientWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.nativeElement.clientWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollHeight", {
        get: /**
         * @return {?}
         */
        function () {
            return this.nativeElement.scrollHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.nativeElement.scrollWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollTop", {
        // Get viewport scroll offset, scrollTop or scrollLeft
        get: 
        // Get viewport scroll offset, scrollTop or scrollLeft
        /**
         * @return {?}
         */
        function () {
            return this.nativeElement.scrollTop;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollLeft", {
        get: /**
         * @return {?}
         */
        function () {
            return this.nativeElement.scrollLeft;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollMaxX", {
        // Get the available scrollable size
        get: 
        // Get the available scrollable size
        /**
         * @return {?}
         */
        function () {
            return this.scrollWidth - this.clientWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollMaxY", {
        get: /**
         * @return {?}
         */
        function () {
            return this.scrollHeight - this.clientHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "contentHeight", {
        get: /**
         * @return {?}
         */
        function () {
            return this.contentWrapperElement.clientHeight;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Activate viewport pointer events such as 'hovered' and 'clicked' events
     */
    /**
     * Activate viewport pointer events such as 'hovered' and 'clicked' events
     * @param {?} destroyed
     * @return {?}
     */
    ScrollViewport.prototype.activatePointerEvents = /**
     * Activate viewport pointer events such as 'hovered' and 'clicked' events
     * @param {?} destroyed
     * @return {?}
     */
    function (destroyed) {
        var _this = this;
        this.hovered = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            // Stream that emits when pointer is moved over the viewport (used to set the hovered state)
            /** @type {?} */
            var mouseMove = fromEvent(_this.nativeElement, 'mousemove', { passive: true }).pipe(stopPropagation());
            // Stream that emits when pointer leaves the viewport (used to remove the hovered state)
            /** @type {?} */
            var mouseLeave = fromEvent(_this.nativeElement, 'mouseleave').pipe(map((/**
             * @return {?}
             */
            function () { return false; })));
            merge(mouseMove, mouseLeave).pipe(tap((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return observer.next(e); })), takeUntil(destroyed)).subscribe();
        }));
        this.clicked = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            /** @type {?} */
            var mouseDown = fromEvent(_this.nativeElement, 'mousedown', { passive: true }).pipe(tap((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return observer.next(e); })));
            /** @type {?} */
            var mouseUp = fromEvent(_this.nativeElement, 'mouseup', { passive: true }).pipe(tap((/**
             * @return {?}
             */
            function () { return observer.next(false); })));
            mouseDown.pipe(switchMap((/**
             * @return {?}
             */
            function () { return mouseUp; })), takeUntil(destroyed)).subscribe();
        }));
    };
    /**
     * Set this directive as a non-functional wrapper, called when a custom viewport is used
     */
    /**
     * Set this directive as a non-functional wrapper, called when a custom viewport is used
     * @return {?}
     */
    ScrollViewport.prototype.setAsWrapper = /**
     * Set this directive as a non-functional wrapper, called when a custom viewport is used
     * @return {?}
     */
    function () {
        // In this case the default viewport and the default content wrapper will act as a mask
        this.nativeElement.className = 'ng-native-scrollbar-hider ng-scroll-layer';
        if (this.nativeElement.firstElementChild) {
            this.nativeElement.firstElementChild.className = 'ng-scroll-layer';
        }
    };
    /**
     * Set this directive as  the viewport, called when no custom viewport is used
     */
    /**
     * Set this directive as  the viewport, called when no custom viewport is used
     * @param {?} customClassName
     * @return {?}
     */
    ScrollViewport.prototype.setAsViewport = /**
     * Set this directive as  the viewport, called when no custom viewport is used
     * @param {?} customClassName
     * @return {?}
     */
    function (customClassName) {
        this.nativeElement.className = "ng-native-scrollbar-hider ng-scroll-viewport " + customClassName;
        // Check if the custom viewport has only one child and set it as the content wrapper
        if (this.nativeElement.firstElementChild) {
            this.contentWrapperElement = (/** @type {?} */ (this.nativeElement.firstElementChild));
            this.contentWrapperElement.classList.add('ng-scroll-content');
        }
    };
    /**
     * Scroll viewport vertically
     */
    /**
     * Scroll viewport vertically
     * @param {?} value
     * @return {?}
     */
    ScrollViewport.prototype.scrollYTo = /**
     * Scroll viewport vertically
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.nativeElement.scrollTop = value;
    };
    /**
     * Scroll viewport horizontally
     */
    /**
     * Scroll viewport horizontally
     * @param {?} value
     * @return {?}
     */
    ScrollViewport.prototype.scrollXTo = /**
     * Scroll viewport horizontally
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.nativeElement.scrollLeft = value;
    };
    ScrollViewport.decorators = [
        { type: Directive, args: [{
                    selector: '[scrollViewport]'
                },] }
    ];
    /** @nocollapse */
    ScrollViewport.ctorParameters = function () { return [
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    return ScrollViewport;
}());
export { ScrollViewport };
if (false) {
    /** @type {?} */
    ScrollViewport.prototype.nativeElement;
    /** @type {?} */
    ScrollViewport.prototype.contentWrapperElement;
    /** @type {?} */
    ScrollViewport.prototype.hovered;
    /** @type {?} */
    ScrollViewport.prototype.clicked;
    /** @type {?} */
    ScrollViewport.prototype.viewPort;
    /**
     * @type {?}
     * @private
     */
    ScrollViewport.prototype.document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLXZpZXdwb3J0LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXNjcm9sbGJhci8iLCJzb3VyY2VzIjpbImxpYi9zY3JvbGwtdmlld3BvcnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFZLE1BQU0sTUFBTSxDQUFDO0FBQzlELE9BQU8sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFckQ7SUFxREUsd0JBQW1CLFFBQW9CLEVBQ0QsUUFBYTtRQURoQyxhQUFRLEdBQVIsUUFBUSxDQUFZO1FBQ0QsYUFBUSxHQUFSLFFBQVEsQ0FBSztRQUNqRCxJQUFJLENBQUMsYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUM7SUFDOUMsQ0FBQztJQXpDRCxzQkFBSSx3Q0FBWTtRQURoQixpREFBaUQ7Ozs7OztRQUNqRDtZQUNFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUM7UUFDekMsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSx1Q0FBVzs7OztRQUFmO1lBQ0UsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQztRQUN4QyxDQUFDOzs7T0FBQTtJQUVELHNCQUFJLHdDQUFZOzs7O1FBQWhCO1lBQ0UsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQztRQUN6QyxDQUFDOzs7T0FBQTtJQUVELHNCQUFJLHVDQUFXOzs7O1FBQWY7WUFDRSxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDO1FBQ3hD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LGlCQUFpQixDQUFDO1NBQ3BFO0lBQ0gsQ0FBQztJQUVEOztPQUVHOzs7Ozs7SUFDSCxzQ0FBYTs7Ozs7SUFBYixVQUFjLGVBQXVCO1FBQ25DLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxHQUFHLGtEQUFnRCxlQUFpQixDQUFDO1FBQ2pHLG9GQUFvRjtRQUNwRixJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLEVBQUU7WUFDeEMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLG1CQUFBLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLEVBQWUsQ0FBQztZQUNqRixJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQy9EO0lBQ0gsQ0FBQztJQUVEOztPQUVHOzs7Ozs7SUFDSCxrQ0FBUzs7Ozs7SUFBVCxVQUFVLEtBQWE7UUFDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0lBQ3ZDLENBQUM7SUFFRDs7T0FFRzs7Ozs7O0lBQ0gsa0NBQVM7Ozs7O0lBQVQsVUFBVSxLQUFhO1FBQ3JCLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztJQUN4QyxDQUFDOztnQkExSEYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxrQkFBa0I7aUJBQzdCOzs7O2dCQVIyQixVQUFVO2dEQTREdkIsTUFBTSxTQUFDLFFBQVE7O0lBcUU5QixxQkFBQztDQUFBLEFBM0hELElBMkhDO1NBeEhZLGNBQWM7OztJQUV6Qix1Q0FBb0M7O0lBRXBDLCtDQUFvQzs7SUFHcEMsaUNBQThCOztJQUU5QixpQ0FBMEI7O0lBeUNkLGtDQUEyQjs7Ozs7SUFDM0Isa0NBQXVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbmplY3QsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAsIHN3aXRjaE1hcCwgdGFrZVVudGlsLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IHN0b3BQcm9wYWdhdGlvbiB9IGZyb20gJy4vc2Nyb2xsYmFyL2NvbW1vbic7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tzY3JvbGxWaWV3cG9ydF0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTY3JvbGxWaWV3cG9ydCB7XHJcbiAgLy8gVmlld3BvcnQgZWxlbWVudFxyXG4gIHJlYWRvbmx5IG5hdGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG4gIC8vIENvbnRlbnQgd3JhcHBlciBlbGVtZW50XHJcbiAgY29udGVudFdyYXBwZXJFbGVtZW50ITogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcG9pbnRlciBldmVudCB3aGVuIHRoZSB2aWV3cG9ydCBpcyBob3ZlcmVkIGFuZCBlbWl0cyBmYWxzZSB2YWx1ZSB3aGVuIGlzbid0IGhvdmVyZWRcclxuICBob3ZlcmVkITogT2JzZXJ2YWJsZTxib29sZWFuPjtcclxuICAvLyBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHZpZXdwb3J0IGlzIGNsaWNrZWRcclxuICBjbGlja2VkITogT2JzZXJ2YWJsZTxhbnk+O1xyXG5cclxuICAvLyBHZXQgdmlld3BvcnQgc2l6ZSwgY2xpZW50SGVpZ2h0IG9yIGNsaWVudFdpZHRoXHJcbiAgZ2V0IGNsaWVudEhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBnZXQgY2xpZW50V2lkdGgoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgfVxyXG5cclxuICBnZXQgc2Nyb2xsSGVpZ2h0KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbEhlaWdodDtcclxuICB9XHJcblxyXG4gIGdldCBzY3JvbGxXaWR0aCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aDtcclxuICB9XHJcblxyXG4gIC8vIEdldCB2aWV3cG9ydCBzY3JvbGwgb2Zmc2V0LCBzY3JvbGxUb3Agb3Igc2Nyb2xsTGVmdFxyXG4gIGdldCBzY3JvbGxUb3AoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNjcm9sbExlZnQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuICB9XHJcblxyXG4gIC8vIEdldCB0aGUgYXZhaWxhYmxlIHNjcm9sbGFibGUgc2l6ZVxyXG4gIGdldCBzY3JvbGxNYXhYKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxXaWR0aCAtIHRoaXMuY2xpZW50V2lkdGg7XHJcbiAgfVxyXG5cclxuICBnZXQgc2Nyb2xsTWF4WSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5jbGllbnRIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBnZXQgY29udGVudEhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudFdyYXBwZXJFbGVtZW50LmNsaWVudEhlaWdodDtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB2aWV3UG9ydDogRWxlbWVudFJlZixcclxuICAgICAgICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvY3VtZW50OiBhbnkpIHtcclxuICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IHZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBY3RpdmF0ZSB2aWV3cG9ydCBwb2ludGVyIGV2ZW50cyBzdWNoIGFzICdob3ZlcmVkJyBhbmQgJ2NsaWNrZWQnIGV2ZW50c1xyXG4gICAqL1xyXG4gIGFjdGl2YXRlUG9pbnRlckV2ZW50cyhkZXN0cm95ZWQ6IE9ic2VydmFibGU8YW55Pik6IHZvaWQge1xyXG4gICAgdGhpcy5ob3ZlcmVkID0gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyOiBPYnNlcnZlcjxhbnk+KSA9PiB7XHJcbiAgICAgIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcG9pbnRlciBpcyBtb3ZlZCBvdmVyIHRoZSB2aWV3cG9ydCAodXNlZCB0byBzZXQgdGhlIGhvdmVyZWQgc3RhdGUpXHJcbiAgICAgIGNvbnN0IG1vdXNlTW92ZSA9IGZyb21FdmVudCh0aGlzLm5hdGl2ZUVsZW1lbnQsICdtb3VzZW1vdmUnLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShzdG9wUHJvcGFnYXRpb24oKSk7XHJcbiAgICAgIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcG9pbnRlciBsZWF2ZXMgdGhlIHZpZXdwb3J0ICh1c2VkIHRvIHJlbW92ZSB0aGUgaG92ZXJlZCBzdGF0ZSlcclxuICAgICAgY29uc3QgbW91c2VMZWF2ZSA9IGZyb21FdmVudCh0aGlzLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWxlYXZlJykucGlwZShtYXAoKCkgPT4gZmFsc2UpKTtcclxuICAgICAgbWVyZ2UobW91c2VNb3ZlLCBtb3VzZUxlYXZlKS5waXBlKFxyXG4gICAgICAgIHRhcCgoZTogZmFsc2UgfCBhbnkpID0+IG9ic2VydmVyLm5leHQoZSkpLFxyXG4gICAgICAgIHRha2VVbnRpbChkZXN0cm95ZWQpXHJcbiAgICAgICkuc3Vic2NyaWJlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmNsaWNrZWQgPSBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pID0+IHtcclxuICAgICAgY29uc3QgbW91c2VEb3duID0gZnJvbUV2ZW50KHRoaXMubmF0aXZlRWxlbWVudCwgJ21vdXNlZG93bicsIHsgcGFzc2l2ZTogdHJ1ZSB9KS5waXBlKFxyXG4gICAgICAgIHRhcCgoZTogYW55KSA9PiBvYnNlcnZlci5uZXh0KGUpKVxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBtb3VzZVVwID0gZnJvbUV2ZW50KHRoaXMubmF0aXZlRWxlbWVudCwgJ21vdXNldXAnLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShcclxuICAgICAgICB0YXAoKCkgPT4gb2JzZXJ2ZXIubmV4dChmYWxzZSkpXHJcbiAgICAgICk7XHJcbiAgICAgIG1vdXNlRG93bi5waXBlKFxyXG4gICAgICAgIHN3aXRjaE1hcCgoKSA9PiBtb3VzZVVwKSxcclxuICAgICAgICB0YWtlVW50aWwoZGVzdHJveWVkKVxyXG4gICAgICApLnN1YnNjcmliZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhpcyBkaXJlY3RpdmUgYXMgYSBub24tZnVuY3Rpb25hbCB3cmFwcGVyLCBjYWxsZWQgd2hlbiBhIGN1c3RvbSB2aWV3cG9ydCBpcyB1c2VkXHJcbiAgICovXHJcbiAgc2V0QXNXcmFwcGVyKCk6IHZvaWQge1xyXG4gICAgLy8gSW4gdGhpcyBjYXNlIHRoZSBkZWZhdWx0IHZpZXdwb3J0IGFuZCB0aGUgZGVmYXVsdCBjb250ZW50IHdyYXBwZXIgd2lsbCBhY3QgYXMgYSBtYXNrXHJcbiAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lID0gJ25nLW5hdGl2ZS1zY3JvbGxiYXItaGlkZXIgbmctc2Nyb2xsLWxheWVyJztcclxuICAgIGlmICh0aGlzLm5hdGl2ZUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpIHtcclxuICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmNsYXNzTmFtZSA9ICduZy1zY3JvbGwtbGF5ZXInO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoaXMgZGlyZWN0aXZlIGFzICB0aGUgdmlld3BvcnQsIGNhbGxlZCB3aGVuIG5vIGN1c3RvbSB2aWV3cG9ydCBpcyB1c2VkXHJcbiAgICovXHJcbiAgc2V0QXNWaWV3cG9ydChjdXN0b21DbGFzc05hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5uYXRpdmVFbGVtZW50LmNsYXNzTmFtZSA9IGBuZy1uYXRpdmUtc2Nyb2xsYmFyLWhpZGVyIG5nLXNjcm9sbC12aWV3cG9ydCAke2N1c3RvbUNsYXNzTmFtZX1gO1xyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1c3RvbSB2aWV3cG9ydCBoYXMgb25seSBvbmUgY2hpbGQgYW5kIHNldCBpdCBhcyB0aGUgY29udGVudCB3cmFwcGVyXHJcbiAgICBpZiAodGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSB7XHJcbiAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCduZy1zY3JvbGwtY29udGVudCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIHZpZXdwb3J0IHZlcnRpY2FsbHlcclxuICAgKi9cclxuICBzY3JvbGxZVG8odmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIHZpZXdwb3J0IGhvcml6b250YWxseVxyXG4gICAqL1xyXG4gIHNjcm9sbFhUbyh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsTGVmdCA9IHZhbHVlO1xyXG4gIH1cclxufVxyXG4iXX0=