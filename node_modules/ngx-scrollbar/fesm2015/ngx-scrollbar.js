import { Directive, ElementRef, Inject, InjectionToken, Injectable, Optional, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Component, ChangeDetectionStrategy, NgZone, ChangeDetectorRef, Input, Output, ViewChild, ContentChild, Pipe, NgModule } from '@angular/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { PortalModule } from '@angular/cdk/portal';
import { getRtlScrollAxisType, Platform, RtlScrollAxisType, PlatformModule } from '@angular/cdk/platform';
import { SmoothScrollManager, SmoothScrollModule } from 'ngx-scrollbar/smooth-scroll';
import { Observable, fromEvent, merge, of, BehaviorSubject, Subject, from, EMPTY, animationFrameScheduler, asyncScheduler } from 'rxjs';
import { tap, map, takeUntil, switchMap, debounceTime, pluck, pairwise, filter, auditTime, catchError, distinctUntilChanged, mergeMap } from 'rxjs/operators';
import { DomSanitizer } from '@angular/platform-browser';
import { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} doc
 * @return {?}
 */
function preventSelection(doc) {
    return tap((/**
     * @return {?}
     */
    () => {
        doc.onselectstart = (/**
         * @return {?}
         */
        () => false);
    }));
}
/**
 * @param {?} doc
 * @return {?}
 */
function enableSelection(doc) {
    return tap((/**
     * @return {?}
     */
    () => {
        doc.onselectstart = null;
    }));
}
/**
 * @return {?}
 */
function stopPropagation() {
    return tap((/**
     * @param {?} e
     * @return {?}
     */
    (e) => e.stopPropagation()));
}
/**
 * Check if pointer is within scrollbar bounds
 * @param {?} e
 * @param {?} rect
 * @return {?}
 */
function isWithinBounds(e, rect) {
    return (e.clientX >= rect.left &&
        e.clientX <= rect.left + rect.width &&
        e.clientY >= rect.top &&
        e.clientY <= rect.top + rect.height);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollViewport {
    /**
     * @param {?} viewPort
     * @param {?} document
     */
    constructor(viewPort, document) {
        this.viewPort = viewPort;
        this.document = document;
        this.nativeElement = viewPort.nativeElement;
    }
    // Get viewport size, clientHeight or clientWidth
    /**
     * @return {?}
     */
    get clientHeight() {
        return this.nativeElement.clientHeight;
    }
    /**
     * @return {?}
     */
    get clientWidth() {
        return this.nativeElement.clientWidth;
    }
    /**
     * @return {?}
     */
    get scrollHeight() {
        return this.nativeElement.scrollHeight;
    }
    /**
     * @return {?}
     */
    get scrollWidth() {
        return this.nativeElement.scrollWidth;
    }
    // Get viewport scroll offset, scrollTop or scrollLeft
    /**
     * @return {?}
     */
    get scrollTop() {
        return this.nativeElement.scrollTop;
    }
    /**
     * @return {?}
     */
    get scrollLeft() {
        return this.nativeElement.scrollLeft;
    }
    // Get the available scrollable size
    /**
     * @return {?}
     */
    get scrollMaxX() {
        return this.scrollWidth - this.clientWidth;
    }
    /**
     * @return {?}
     */
    get scrollMaxY() {
        return this.scrollHeight - this.clientHeight;
    }
    /**
     * @return {?}
     */
    get contentHeight() {
        return this.contentWrapperElement.clientHeight;
    }
    /**
     * Activate viewport pointer events such as 'hovered' and 'clicked' events
     * @param {?} destroyed
     * @return {?}
     */
    activatePointerEvents(destroyed) {
        this.hovered = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            // Stream that emits when pointer is moved over the viewport (used to set the hovered state)
            /** @type {?} */
            const mouseMove = fromEvent(this.nativeElement, 'mousemove', { passive: true }).pipe(stopPropagation());
            // Stream that emits when pointer leaves the viewport (used to remove the hovered state)
            /** @type {?} */
            const mouseLeave = fromEvent(this.nativeElement, 'mouseleave').pipe(map((/**
             * @return {?}
             */
            () => false)));
            merge(mouseMove, mouseLeave).pipe(tap((/**
             * @param {?} e
             * @return {?}
             */
            (e) => observer.next(e))), takeUntil(destroyed)).subscribe();
        }));
        this.clicked = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            /** @type {?} */
            const mouseDown = fromEvent(this.nativeElement, 'mousedown', { passive: true }).pipe(tap((/**
             * @param {?} e
             * @return {?}
             */
            (e) => observer.next(e))));
            /** @type {?} */
            const mouseUp = fromEvent(this.nativeElement, 'mouseup', { passive: true }).pipe(tap((/**
             * @return {?}
             */
            () => observer.next(false))));
            mouseDown.pipe(switchMap((/**
             * @return {?}
             */
            () => mouseUp)), takeUntil(destroyed)).subscribe();
        }));
    }
    /**
     * Set this directive as a non-functional wrapper, called when a custom viewport is used
     * @return {?}
     */
    setAsWrapper() {
        // In this case the default viewport and the default content wrapper will act as a mask
        this.nativeElement.className = 'ng-native-scrollbar-hider ng-scroll-layer';
        if (this.nativeElement.firstElementChild) {
            this.nativeElement.firstElementChild.className = 'ng-scroll-layer';
        }
    }
    /**
     * Set this directive as  the viewport, called when no custom viewport is used
     * @param {?} customClassName
     * @return {?}
     */
    setAsViewport(customClassName) {
        this.nativeElement.className = `ng-native-scrollbar-hider ng-scroll-viewport ${customClassName}`;
        // Check if the custom viewport has only one child and set it as the content wrapper
        if (this.nativeElement.firstElementChild) {
            this.contentWrapperElement = (/** @type {?} */ (this.nativeElement.firstElementChild));
            this.contentWrapperElement.classList.add('ng-scroll-content');
        }
    }
    /**
     * Scroll viewport vertically
     * @param {?} value
     * @return {?}
     */
    scrollYTo(value) {
        this.nativeElement.scrollTop = value;
    }
    /**
     * Scroll viewport horizontally
     * @param {?} value
     * @return {?}
     */
    scrollXTo(value) {
        this.nativeElement.scrollLeft = value;
    }
}
ScrollViewport.decorators = [
    { type: Directive, args: [{
                selector: '[scrollViewport]'
            },] }
];
/** @nocollapse */
ScrollViewport.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
if (false) {
    /** @type {?} */
    ScrollViewport.prototype.nativeElement;
    /** @type {?} */
    ScrollViewport.prototype.contentWrapperElement;
    /** @type {?} */
    ScrollViewport.prototype.hovered;
    /** @type {?} */
    ScrollViewport.prototype.clicked;
    /** @type {?} */
    ScrollViewport.prototype.viewPort;
    /**
     * @type {?}
     * @private
     */
    ScrollViewport.prototype.document;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NG_SCROLLBAR_OPTIONS = new InjectionToken('NG_SCROLLBAR_OPTIONS');
/**
 * @record
 */
function NgScrollbarOptions() { }
if (false) {
    /**
     * Sets the scroll axis of the viewport, there are 3 options:
     *
     * - `vertical` Use both vertical and horizontal scrollbar-control
     * - `horizontal` Use both vertical and horizontal scrollbar-control
     * - `all` Use both vertical and horizontal scrollbar-control
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.track;
    /**
     * When to show the scrollbar, and there are 3 options:
     *
     * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar-control
     * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
     * - `always` Scrollbars are always shown even if the viewport is not scrollable
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.visibility;
    /**
     *  Sets the appearance of the scrollbar, there are 2 options:
     *
     * - `standard` (default) scrollbar space will be reserved just like with native scrollbar-control.
     * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.appearance;
    /**
     * Sets the position of each scrollbar, there are 4 options:
     *
     * - `native` (Default) Use the default position like in native scrollbar-control.
     * - `invertY` Inverts vertical scrollbar position
     * - `invertX` Inverts Horizontal scrollbar position
     * - `invertAll` Inverts both scrollbar-control positions
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.position;
    /**
     * Sets the pointer events method
     * Use viewport pointer events  to handle dragging and track click (This makes scrolling work when mouse is over the scrollbar)
     * Use scrollbar pointer events to handle dragging and track click
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.pointerEventsMethod;
    /**
     * A class forwarded to scrollable viewport element
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.viewClass;
    /**
     * A class forwarded to the scrollbar track element
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.trackClass;
    /**
     * A class forwarded to the scrollbar thumb element
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.thumbClass;
    /**
     * The minimum scrollbar thumb size in px
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.minThumbSize;
    /**
     * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.trackClickScrollDuration;
    /**
     * A flag used to enable/disable the scrollbar pointer events
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.pointerEventsDisabled;
    /**
     * Debounce interval for detecting changes via window.resize event
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.windowResizeDebounce;
    /**
     * Debounce interval for detecting changes via ResizeObserver
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.sensorDebounce;
    /**
     * Whether ResizeObserver is disabled
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.sensorDisabled;
    /**
     * Scroll Audit Time
     * @type {?|undefined}
     */
    NgScrollbarOptions.prototype.scrollAuditTime;
}
/**
 * Set of attributes added on the scrollbar wrapper
 * @record
 */
function NgScrollbarState() { }
if (false) {
    /** @type {?|undefined} */
    NgScrollbarState.prototype.position;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.track;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.appearance;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.visibility;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.deactivated;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.pointerEventsMethod;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.dir;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.verticalUsed;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.horizontalUsed;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.isVerticallyScrollable;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.isHorizontallyScrollable;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.verticalHovered;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.horizontalHovered;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.verticalDragging;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.horizontalDragging;
    /** @type {?|undefined} */
    NgScrollbarState.prototype.scrollbarClicked;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultOptions = {
    viewClass: '',
    trackClass: '',
    thumbClass: '',
    track: 'vertical',
    appearance: 'compact',
    visibility: 'native',
    position: 'native',
    pointerEventsMethod: 'viewport',
    trackClickScrollDuration: 300,
    minThumbSize: 20,
    windowResizeDebounce: 0,
    sensorDebounce: 0,
    scrollAuditTime: 0
};
class ScrollbarManager {
    /**
     * @param {?} options
     */
    constructor(options) {
        this.globalOptions = options ? Object.assign({}, defaultOptions, options) : defaultOptions;
        this.rtlScrollAxisType = getRtlScrollAxisType();
    }
}
ScrollbarManager.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ScrollbarManager.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_SCROLLBAR_OPTIONS,] }] }
];
/** @nocollapse */ ScrollbarManager.ngInjectableDef = ɵɵdefineInjectable({ factory: function ScrollbarManager_Factory() { return new ScrollbarManager(ɵɵinject(NG_SCROLLBAR_OPTIONS, 8)); }, token: ScrollbarManager, providedIn: "root" });
if (false) {
    /** @type {?} */
    ScrollbarManager.prototype.globalOptions;
    /** @type {?} */
    ScrollbarManager.prototype.rtlScrollAxisType;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NativeScrollbarSizeFactory {
    /**
     * @param {?} document
     * @param {?} manager
     * @param {?} platform
     */
    constructor(document, manager, platform) {
        this.document = document;
        this.manager = manager;
        this.platform = platform;
        if (platform.isBrowser) {
            of(null).pipe(tap((/**
             * @return {?}
             */
            () => this._nativeScrollbarSize = new BehaviorSubject(this.getNativeScrollbarSize()))), tap((/**
             * @return {?}
             */
            () => this.nativeScrollbarSize = this._nativeScrollbarSize.asObservable())), switchMap((/**
             * @return {?}
             */
            () => fromEvent(this.document.defaultView, 'resize', { passive: true }))), debounceTime((/** @type {?} */ (this.manager.globalOptions.windowResizeDebounce))), tap((/**
             * @return {?}
             */
            () => this._nativeScrollbarSize.next(this.getNativeScrollbarSize())))).subscribe();
        }
    }
    /**
     * Get native scrollbar size
     * @private
     * @return {?}
     */
    getNativeScrollbarSize() {
        if (this.platform.ANDROID || this.platform.IOS) {
            return 6;
        }
        /** @type {?} */
        const box = this.document.createElement('div');
        box.className = 'ng-scrollbar-measure';
        this.document.body.appendChild(box);
        /** @type {?} */
        const size = box.getBoundingClientRect().right;
        this.document.body.removeChild(box);
        // if size is 0, return 15 (for MAC OS browsers)
        return size || 15;
    }
}
NativeScrollbarSizeFactory.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
NativeScrollbarSizeFactory.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ScrollbarManager },
    { type: Platform }
];
/** @nocollapse */ NativeScrollbarSizeFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function NativeScrollbarSizeFactory_Factory() { return new NativeScrollbarSizeFactory(ɵɵinject(DOCUMENT), ɵɵinject(ScrollbarManager), ɵɵinject(Platform)); }, token: NativeScrollbarSizeFactory, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NativeScrollbarSizeFactory.prototype._nativeScrollbarSize;
    /** @type {?} */
    NativeScrollbarSizeFactory.prototype.nativeScrollbarSize;
    /**
     * @type {?}
     * @private
     */
    NativeScrollbarSizeFactory.prototype.document;
    /**
     * @type {?}
     * @private
     */
    NativeScrollbarSizeFactory.prototype.manager;
    /**
     * @type {?}
     * @private
     */
    NativeScrollbarSizeFactory.prototype.platform;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgScrollbar {
    /**
     * @param {?} el
     * @param {?} zone
     * @param {?} changeDetectorRef
     * @param {?} dir
     * @param {?} smoothScroll
     * @param {?} manager
     * @param {?} nativeScrollbarSizeFactory
     */
    constructor(el, zone, changeDetectorRef, dir, smoothScroll, manager, nativeScrollbarSizeFactory) {
        this.el = el;
        this.zone = zone;
        this.changeDetectorRef = changeDetectorRef;
        this.dir = dir;
        this.smoothScroll = smoothScroll;
        this.manager = manager;
        this.nativeScrollbarSizeFactory = nativeScrollbarSizeFactory;
        /**
         * A class forwarded to scrollable viewport element
         */
        this.viewClass = this.manager.globalOptions.viewClass;
        /**
         * A class forwarded to the scrollbar track element
         */
        this.trackClass = this.manager.globalOptions.trackClass;
        /**
         * A class forwarded to the scrollbar thumb element
         */
        this.thumbClass = this.manager.globalOptions.thumbClass;
        /**
         * Minimum scrollbar thumb size
         */
        this.minThumbSize = this.manager.globalOptions.minThumbSize;
        /**
         * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
         */
        this.trackClickScrollDuration = this.manager.globalOptions.trackClickScrollDuration;
        /**
         * A flag used to enable/disable the scrollbar thumb dragged event
         */
        this.pointerEventsDisabled = this.manager.globalOptions.pointerEventsDisabled;
        /**
         * Sets the pointer events method
         * Use viewport pointer events  to handle dragging and track click (This makes scrolling work when mouse is over the scrollbar)
         * Use scrollbar pointer events to handle dragging and track click
         */
        this.pointerEventsMethod = this.manager.globalOptions.pointerEventsMethod;
        /**
         * Disable custom scrollbar and switch back to native scrollbar
         */
        this.disabled = false;
        /**
         * Sets the supported scroll track of the viewport, there are 3 options:
         *
         * - `vertical` Use both vertical and horizontal scrollbar
         * - `horizontal` Use both vertical and horizontal scrollbar
         * - `all` Use both vertical and horizontal scrollbar
         */
        this.track = this.manager.globalOptions.track;
        /**
         * When to show the scrollbar, and there are 3 options:
         *
         * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
         * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
         * - `always` Scrollbars are always shown even if the viewport is not scrollable
         */
        this.visibility = this.manager.globalOptions.visibility;
        /**
         *  Sets the appearance of the scrollbar, there are 2 options:
         *
         * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
         * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
         */
        this.appearance = this.manager.globalOptions.appearance;
        /**
         * Sets the position of each scrollbar, there are 4 options:
         *
         * - `native` (Default) Use the default position like in native scrollbar.
         * - `invertY` Inverts vertical scrollbar position
         * - `invertX` Inverts Horizontal scrollbar position
         * - `invertAll` Inverts both scrollbar positions
         */
        this.position = this.manager.globalOptions.position;
        /**
         * Debounce interval for detecting changes via ResizeObserver
         */
        this.sensorDebounce = this.manager.globalOptions.sensorDebounce;
        /**
         * Whether ResizeObserver is disabled
         */
        this.sensorDisabled = this.manager.globalOptions.sensorDisabled;
        /**
         * Scroll Audit Time
         */
        this.scrollAuditTime = this.manager.globalOptions.scrollAuditTime;
        /**
         * Steam that emits when scrollbar is updated
         */
        this.updated = new EventEmitter();
        /**
         * Set of attributes added on the scrollbar wrapper
         */
        this.state = {};
        /**
         * Stream that destroys components' observables
         */
        this.destroyed = new Subject();
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this.el.nativeElement;
    }
    /**
     * Update local state with each change detection
     * @private
     * @return {?}
     */
    updateState() {
        /** @type {?} */
        let verticalUsed = false;
        /** @type {?} */
        let horizontalUsed = false;
        /** @type {?} */
        let isVerticallyScrollable = false;
        /** @type {?} */
        let isHorizontallyScrollable = false;
        // Check if vertical scrollbar should be displayed
        if (this.track === 'all' || this.track === 'vertical') {
            isVerticallyScrollable = this.viewport.scrollHeight > this.viewport.clientHeight;
            verticalUsed = this.visibility === 'always' || isVerticallyScrollable;
        }
        // Check if horizontal scrollbar should be displayed
        if (this.track === 'all' || this.track === 'horizontal') {
            isHorizontallyScrollable = this.viewport.scrollWidth > this.viewport.clientWidth;
            horizontalUsed = this.visibility === 'always' || isHorizontallyScrollable;
        }
        // Update inner wrapper attributes
        this._updateState({
            position: this.position,
            track: this.track,
            appearance: this.appearance,
            visibility: this.visibility,
            deactivated: this.disabled,
            dir: this.dir.value,
            pointerEventsMethod: this.pointerEventsMethod,
            verticalUsed,
            horizontalUsed,
            isVerticallyScrollable,
            isHorizontallyScrollable
        });
    }
    /**
     * @private
     * @param {?} state
     * @return {?}
     */
    _updateState(state) {
        this.state = Object.assign({}, this.state, state);
        this.changeDetectorRef.detectChanges();
    }
    /**
     * @private
     * @param {?} property
     * @return {?}
     */
    getScrolledByDirection(property) {
        /** @type {?} */
        let event;
        return this.scrolled.pipe(tap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => event = e)), pluck('target', property), pairwise(), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([prev, curr]) => prev !== curr)), map((/**
         * @return {?}
         */
        () => event)));
    }
    /**
     * Set hovered state if a scrollbar is being hovered
     * @param {?} hovered
     * @return {?}
     */
    setHovered(hovered) {
        this.zone.run((/**
         * @return {?}
         */
        () => this._updateState(Object.assign({}, hovered))));
    }
    /**
     * Set dragging state if a scrollbar is being dragged
     * @param {?} dragging
     * @return {?}
     */
    setDragging(dragging) {
        this.zone.run((/**
         * @return {?}
         */
        () => this._updateState(Object.assign({}, dragging))));
    }
    /**
     * Set clicked state if a scrollbar track is being click
     * @param {?} scrollbarClicked
     * @return {?}
     */
    setClicked(scrollbarClicked) {
        this.zone.run((/**
         * @return {?}
         */
        () => this._updateState({ scrollbarClicked })));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Set the viewport based on user choice
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            if (this.customViewPort) {
                this.viewport = this.customViewPort;
                this.defaultViewPort.setAsWrapper();
            }
            else {
                this.viewport = this.defaultViewPort;
            }
            // Activate the selected viewport
            this.viewport.setAsViewport((/** @type {?} */ (this.viewClass)));
            /** @type {?} */
            let scrollStream = fromEvent(this.viewport.nativeElement, 'scroll', { passive: true });
            // Throttle scroll event if 'scrollAuditTime' is set
            scrollStream = this.scrollAuditTime ? scrollStream.pipe(auditTime(this.scrollAuditTime)) : scrollStream;
            // Initialize scroll streams
            this.scrolled = new Observable((/**
             * @param {?} observer
             * @return {?}
             */
            (observer) => scrollStream.pipe(takeUntil(this.destroyed)).subscribe(observer)));
            this.verticalScrolled = this.getScrolledByDirection('scrollTop');
            this.horizontalScrolled = this.getScrolledByDirection('scrollLeft');
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.updateState();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyed.next();
        this.destroyed.complete();
    }
    /**
     * Update local state and the internal scrollbar controls
     * @return {?}
     */
    update() {
        if (!this.state.horizontalUsed) {
            // Auto-height: Set component height to content height
            this.nativeElement.style.height = `${this.viewport.contentHeight}px`;
        }
        this.updated.next();
        this.changeDetectorRef.detectChanges();
    }
    /**
     * Smooth scroll functions
     * @param {?} options
     * @return {?}
     */
    scrollTo(options) {
        return this.smoothScroll.scrollTo(this.viewport.nativeElement, options);
    }
    /**
     * Scroll to element by reference or selector
     * @param {?} target
     * @param {?=} options
     * @return {?}
     */
    scrollToElement(target, options) {
        return this.smoothScroll.scrollToElement(this.viewport.nativeElement, target, options);
    }
}
NgScrollbar.decorators = [
    { type: Component, args: [{
                selector: 'ng-scrollbar',
                exportAs: 'ngScrollbar',
                template: "<div class=\"ng-scrollbar-wrapper\" [ngAttr]=\"state\">\r\n  <div class=\"ng-scroll-viewport-wrapper\"\r\n       (resizeSensor)=\"update()\"\r\n       [sensorDebounce]=\"sensorDebounce\"\r\n       [sensorDisabled]=\"sensorDisabled\">\r\n    <div scrollViewport\r\n         [style]=\"nativeScrollbarSizeFactory.nativeScrollbarSize | async | cssVariable: 'native-scrollbar-size'\">\r\n      <div>\r\n        <ng-content></ng-content>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <ng-container *ngIf=\"!disabled\">\r\n    <scrollbar-x *ngIf=\"state.horizontalUsed\"\r\n                 [attr.scrollable]=\"state.isHorizontallyScrollable\"\r\n                 [attr.fit]=\"state.verticalUsed\">\r\n    </scrollbar-x>\r\n    <scrollbar-y *ngIf=\"state.verticalUsed\"\r\n                 [attr.scrollable]=\"state.isVerticallyScrollable\"\r\n                 [attr.fit]=\"state.horizontalUsed\">\r\n    </scrollbar-y>\r\n  </ng-container>\r\n</div>\r\n\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { '[class.ng-scrollbar]': 'true' },
                styles: ["::ng-deep .ng-scrollbar-measure{left:0;overflow:scroll;position:fixed;top:-9999px}:host{--scrollbar-border-radius:7px;--scrollbar-padding:4px;--scrollbar-track-color:transparent;--scrollbar-thumb-color:rgba(0, 0, 0, 0.2);--scrollbar-thumb-hover-color:var(--scrollbar-thumb-color);--scrollbar-size:5px;--scrollbar-hover-size:var(--scrollbar-size);--scrollbar-thumb-transition:height ease-out 150ms,width ease-out 150ms;--scrollbar-track-transition:height ease-out 150ms,width ease-out 150ms;display:block;position:relative;height:100%;max-height:100%;max-width:100%}:host>.ng-scrollbar-wrapper{--scrollbar-total-size:calc(var(--scrollbar-size) + var(--scrollbar-padding) * 2);--vertical-scrollbar-size:var(--scrollbar-size);--horizontal-scrollbar-size:var(--scrollbar-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2)}:host>.ng-scrollbar-wrapper[verticalDragging=true],:host>.ng-scrollbar-wrapper[verticalHovered=true]{--vertical-scrollbar-size:var(--scrollbar-hover-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[horizontalDragging=true],:host>.ng-scrollbar-wrapper[horizontalHovered=true]{--horizontal-scrollbar-size:var(--scrollbar-hover-size);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:0;right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:var(--scrollbar-total-size);right:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:var(--scrollbar-total-size);right:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:0;right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{top:0;bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{top:var(--scrollbar-total-size);bottom:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-top:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{bottom:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{left:0;right:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{right:0;left:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]>.scrollbar-control{opacity:0;transition-property:opacity;transition-duration:.4s;transition-delay:.8s}:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:active>.scrollbar-control,:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:focus>.scrollbar-control,:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:hover>.scrollbar-control{opacity:1;transition-duration:.4s;transition-delay:0s}:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-x:auto;overflow-y:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-y:auto;overflow-x:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow:auto}.ng-scroll-viewport-wrapper{overflow:hidden}.ng-scroll-viewport{-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position}::ng-deep .ng-scroll-content{position:relative!important;display:inline-block;min-width:100%}.ng-scroll-layer,.ng-scroll-viewport-wrapper,.ng-scrollbar-wrapper,::ng-deep .ng-scroll-viewport{position:absolute;left:0;right:0;top:0;bottom:0}", "::ng-deep .ng-scrollbar-wrapper[pointerEventsMethod=viewport]>.scrollbar-control{pointer-events:none}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control{position:absolute;display:flex;justify-content:center;align-items:center;transition:var(--scrollbar-track-transition)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}::ng-deep .ng-scrollbar-track{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-track-color);overflow:hidden;transition:var(--scrollbar-track-transition);cursor:default}::ng-deep .ng-scrollbar-thumb{box-sizing:border-box;position:relative;border-radius:inherit;background-color:var(--scrollbar-thumb-color);transform:translateZ(0);transition:var(--scrollbar-thumb-transition)}"]
            }] }
];
/** @nocollapse */
NgScrollbar.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: Directionality },
    { type: SmoothScrollManager },
    { type: ScrollbarManager },
    { type: NativeScrollbarSizeFactory }
];
NgScrollbar.propDecorators = {
    viewClass: [{ type: Input }],
    trackClass: [{ type: Input }],
    thumbClass: [{ type: Input }],
    minThumbSize: [{ type: Input }],
    trackClickScrollDuration: [{ type: Input }],
    pointerEventsDisabled: [{ type: Input }],
    pointerEventsMethod: [{ type: Input }],
    disabled: [{ type: Input }],
    track: [{ type: Input }],
    visibility: [{ type: Input }],
    appearance: [{ type: Input }],
    position: [{ type: Input }],
    sensorDebounce: [{ type: Input }],
    sensorDisabled: [{ type: Input }],
    scrollAuditTime: [{ type: Input }],
    updated: [{ type: Output }],
    defaultViewPort: [{ type: ViewChild, args: [ScrollViewport, { static: true },] }],
    customViewPort: [{ type: ContentChild, args: [ScrollViewport, { static: true },] }]
};
if (false) {
    /**
     * A class forwarded to scrollable viewport element
     * @type {?}
     */
    NgScrollbar.prototype.viewClass;
    /**
     * A class forwarded to the scrollbar track element
     * @type {?}
     */
    NgScrollbar.prototype.trackClass;
    /**
     * A class forwarded to the scrollbar thumb element
     * @type {?}
     */
    NgScrollbar.prototype.thumbClass;
    /**
     * Minimum scrollbar thumb size
     * @type {?}
     */
    NgScrollbar.prototype.minThumbSize;
    /**
     * The duration which the scrolling takes to reach its target when scrollbar rail is clicked
     * @type {?}
     */
    NgScrollbar.prototype.trackClickScrollDuration;
    /**
     * A flag used to enable/disable the scrollbar thumb dragged event
     * @type {?}
     */
    NgScrollbar.prototype.pointerEventsDisabled;
    /**
     * Sets the pointer events method
     * Use viewport pointer events  to handle dragging and track click (This makes scrolling work when mouse is over the scrollbar)
     * Use scrollbar pointer events to handle dragging and track click
     * @type {?}
     */
    NgScrollbar.prototype.pointerEventsMethod;
    /**
     * Disable custom scrollbar and switch back to native scrollbar
     * @type {?}
     */
    NgScrollbar.prototype.disabled;
    /**
     * Sets the supported scroll track of the viewport, there are 3 options:
     *
     * - `vertical` Use both vertical and horizontal scrollbar
     * - `horizontal` Use both vertical and horizontal scrollbar
     * - `all` Use both vertical and horizontal scrollbar
     * @type {?}
     */
    NgScrollbar.prototype.track;
    /**
     * When to show the scrollbar, and there are 3 options:
     *
     * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
     * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
     * - `always` Scrollbars are always shown even if the viewport is not scrollable
     * @type {?}
     */
    NgScrollbar.prototype.visibility;
    /**
     *  Sets the appearance of the scrollbar, there are 2 options:
     *
     * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
     * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
     * @type {?}
     */
    NgScrollbar.prototype.appearance;
    /**
     * Sets the position of each scrollbar, there are 4 options:
     *
     * - `native` (Default) Use the default position like in native scrollbar.
     * - `invertY` Inverts vertical scrollbar position
     * - `invertX` Inverts Horizontal scrollbar position
     * - `invertAll` Inverts both scrollbar positions
     * @type {?}
     */
    NgScrollbar.prototype.position;
    /**
     * Debounce interval for detecting changes via ResizeObserver
     * @type {?}
     */
    NgScrollbar.prototype.sensorDebounce;
    /**
     * Whether ResizeObserver is disabled
     * @type {?}
     */
    NgScrollbar.prototype.sensorDisabled;
    /**
     * Scroll Audit Time
     * @type {?}
     */
    NgScrollbar.prototype.scrollAuditTime;
    /**
     * Steam that emits when scrollbar is updated
     * @type {?}
     */
    NgScrollbar.prototype.updated;
    /**
     * Default viewport reference
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.defaultViewPort;
    /**
     * Custom viewport reference
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.customViewPort;
    /**
     * Viewport Element
     * @type {?}
     */
    NgScrollbar.prototype.viewport;
    /**
     * Set of attributes added on the scrollbar wrapper
     * @type {?}
     */
    NgScrollbar.prototype.state;
    /**
     * Stream that destroys components' observables
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.destroyed;
    /**
     * Stream that emits on scroll event
     * @type {?}
     */
    NgScrollbar.prototype.scrolled;
    /**
     * Steam that emits scroll event for vertical scrollbar
     * @type {?}
     */
    NgScrollbar.prototype.verticalScrolled;
    /**
     * Steam that emits scroll event for horizontal scrollbar
     * @type {?}
     */
    NgScrollbar.prototype.horizontalScrolled;
    /**
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.el;
    /**
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.dir;
    /**
     * @type {?}
     * @private
     */
    NgScrollbar.prototype.smoothScroll;
    /** @type {?} */
    NgScrollbar.prototype.manager;
    /** @type {?} */
    NgScrollbar.prototype.nativeScrollbarSizeFactory;
}
/**
 * @record
 */
function ScrollbarDragging() { }
if (false) {
    /** @type {?|undefined} */
    ScrollbarDragging.prototype.verticalDragging;
    /** @type {?|undefined} */
    ScrollbarDragging.prototype.horizontalDragging;
}
/**
 * @record
 */
function ScrollbarHovered() { }
if (false) {
    /** @type {?|undefined} */
    ScrollbarHovered.prototype.verticalHovered;
    /** @type {?|undefined} */
    ScrollbarHovered.prototype.horizontalHovered;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CssVariable {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    /**
     * @param {?} size
     * @param {?} variableName
     * @return {?}
     */
    transform(size, variableName) {
        if (size === null) {
            size = 0;
        }
        return this.sanitizer.bypassSecurityTrustStyle(`--${variableName}: -${size}px`);
    }
}
CssVariable.decorators = [
    { type: Pipe, args: [{
                name: 'cssVariable'
            },] }
];
/** @nocollapse */
CssVariable.ctorParameters = () => [
    { type: DomSanitizer }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    CssVariable.prototype.sanitizer;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgAttr {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
    }
    /**
     * @param {?} attrs
     * @return {?}
     */
    set ngAttr(attrs) {
        for (const [key, value] of Object.entries(attrs)) {
            ((/** @type {?} */ (this.el.nativeElement))).setAttribute(key, value);
        }
    }
}
NgAttr.decorators = [
    { type: Directive, args: [{ selector: '[ngAttr]' },] }
];
/** @nocollapse */
NgAttr.ctorParameters = () => [
    { type: ElementRef }
];
NgAttr.propDecorators = {
    ngAttr: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgAttr.prototype.el;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Factory that initialize the ResizeObserver if available in the browser
 * Otherwise, it lazy-loads the ResizeObserver polyfill
 */
class ResizeObserverFactory {
    /**
     * @param {?} document
     * @param {?} platform
     */
    constructor(document, platform) {
        this.resizeObserverSource = new BehaviorSubject(null);
        this.resizeObserverLoader = this.resizeObserverSource.asObservable();
        if (platform.isBrowser) {
            /** @type {?} */
            const resizeObserverApi = document.defaultView.ResizeObserver
                ? of(document.defaultView.ResizeObserver)
                : from(import('@juggle/resize-observer')).pipe(map((/**
                 * @param {?} module
                 * @return {?}
                 */
                (module) => module.ResizeObserver)), catchError((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    console.log('Unable to load ResizeObserver polyfill', e);
                    return EMPTY;
                })));
            this.resizeObserverSource.next(resizeObserverApi);
        }
    }
}
ResizeObserverFactory.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ResizeObserverFactory.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Platform }
];
/** @nocollapse */ ResizeObserverFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function ResizeObserverFactory_Factory() { return new ResizeObserverFactory(ɵɵinject(DOCUMENT), ɵɵinject(Platform)); }, token: ResizeObserverFactory, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ResizeObserverFactory.prototype.resizeObserverSource;
    /** @type {?} */
    ResizeObserverFactory.prototype.resizeObserverLoader;
}
class ResizeSensor {
    /**
     * @param {?} zone
     * @param {?} platform
     * @param {?} resizeObserverFactory
     * @param {?} scrollbar
     */
    constructor(zone, platform, resizeObserverFactory, scrollbar) {
        this.zone = zone;
        this.platform = platform;
        this.resizeObserverFactory = resizeObserverFactory;
        this.scrollbar = scrollbar;
        this._disabled = false;
        this._subscription = null;
        this.resizeSensor = new EventEmitter();
        if (!scrollbar) {
            throw new Error('[NgScrollbar Resize Sensor Directive]: Host element must be an NgScrollbar component.');
        }
    }
    /**
     * Debounce interval for emitting the changes.
     * @return {?}
     */
    get debounce() {
        return this._debounce;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set debounce(value) {
        this._debounce = coerceNumberProperty(value);
        this._subscribe();
    }
    /**
     * Whether ResizeObserver is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._disabled ? this._unsubscribe() : this._subscribe();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this._subscription && !this._disabled) {
            this._subscribe();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unsubscribe();
    }
    /**
     * @private
     * @param {?} ResizeObserver
     * @return {?}
     */
    _createObserver(ResizeObserver) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this._resizeObserver = new ResizeObserver((/**
             * @return {?}
             */
            () => observer.next()));
            this._resizeObserver.observe(this.scrollbar.viewport.nativeElement);
            if (this.scrollbar.viewport.contentWrapperElement) {
                this._resizeObserver.observe(this.scrollbar.viewport.contentWrapperElement);
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _subscribe() {
        this._unsubscribe();
        if (this.platform.isBrowser) {
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this._subscription = this.resizeObserverFactory.resizeObserverLoader.pipe(switchMap((/**
                 * @param {?} moduleObservable
                 * @return {?}
                 */
                (moduleObservable) => moduleObservable)), switchMap((/**
                 * @param {?} ResizeObserver
                 * @return {?}
                 */
                (ResizeObserver) => {
                    if (ResizeObserver) {
                        /** @type {?} */
                        const stream = this._createObserver(ResizeObserver);
                        return this.debounce ? stream.pipe(debounceTime(this._debounce)) : stream;
                    }
                    else {
                        return EMPTY;
                    }
                }))).subscribe((/**
                 * @return {?}
                 */
                () => this.resizeSensor.emit()));
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    _unsubscribe() {
        if (this._resizeObserver) {
            this._resizeObserver.disconnect();
        }
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
    }
}
ResizeSensor.decorators = [
    { type: Directive, args: [{ selector: '[resizeSensor]' },] }
];
/** @nocollapse */
ResizeSensor.ctorParameters = () => [
    { type: NgZone },
    { type: Platform },
    { type: ResizeObserverFactory },
    { type: NgScrollbar }
];
ResizeSensor.propDecorators = {
    debounce: [{ type: Input, args: ['sensorDebounce',] }],
    disabled: [{ type: Input, args: ['sensorDisabled',] }],
    resizeSensor: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype._debounce;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype._subscription;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype._resizeObserver;
    /** @type {?} */
    ResizeSensor.prototype.resizeSensor;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype.platform;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype.resizeObserverFactory;
    /**
     * @type {?}
     * @private
     */
    ResizeSensor.prototype.scrollbar;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class TrackAdapter {
    /**
     * @protected
     * @param {?} cmp
     * @param {?} trackElement
     * @param {?} document
     */
    constructor(cmp, trackElement, document) {
        this.cmp = cmp;
        this.trackElement = trackElement;
        this.document = document;
    }
    // Stream that emits when the track element is clicked
    /**
     * @return {?}
     */
    get clicked() {
        /** @type {?} */
        const mouseDown = fromEvent(this.trackElement, 'mousedown', { passive: true }).pipe(stopPropagation(), preventSelection(this.document));
        /** @type {?} */
        const mouseup = fromEvent(this.document, 'mouseup', { passive: true }).pipe(stopPropagation(), enableSelection(this.document), switchMap((/**
         * @return {?}
         */
        () => EMPTY)));
        return merge(mouseDown, mouseup);
    }
    // Stream that emits when the track element is hovered
    /**
     * @return {?}
     */
    get hovered() {
        /** @type {?} */
        const mouseEnter = fromEvent(this.trackElement, 'mouseenter', { passive: true }).pipe(stopPropagation(), map((/**
         * @return {?}
         */
        () => true)));
        /** @type {?} */
        const mouseLeave = fromEvent(this.trackElement, 'mouseleave', { passive: true }).pipe(stopPropagation(), map((/**
         * @return {?}
         */
        () => false)));
        return merge(mouseEnter, mouseLeave);
    }
    // Get track client rect
    /**
     * @return {?}
     */
    get clientRect() {
        return this.trackElement.getBoundingClientRect();
    }
    /**
     * Stream that emits when scrollbar track is clicked
     * @param {?} e
     * @param {?} thumbSize
     * @param {?} scrollSize
     * @return {?}
     */
    onTrackClicked(e, thumbSize, scrollSize) {
        return of(e).pipe(pluck(this.pageProperty), 
        // Calculate scrollTo position
        map((/**
         * @param {?} pageOffset
         * @return {?}
         */
        (pageOffset) => {
            /** @type {?} */
            const clickOffset = pageOffset - this.offset;
            /** @type {?} */
            const offset = clickOffset - (thumbSize / 2);
            /** @type {?} */
            const ratio = offset / this.size;
            return ratio * scrollSize;
        })), 
        // Smooth scroll to position
        tap((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.cmp.scrollTo(Object.assign({}, this.mapToScrollToOption(value), { duration: coerceNumberProperty(this.cmp.trackClickScrollDuration) }));
        })));
    }
}
if (false) {
    /**
     * @type {?}
     * @protected
     */
    TrackAdapter.prototype.cmp;
    /**
     * @type {?}
     * @protected
     */
    TrackAdapter.prototype.trackElement;
    /**
     * @type {?}
     * @protected
     */
    TrackAdapter.prototype.document;
    /**
     * @abstract
     * @return {?}
     */
    TrackAdapter.prototype.pageProperty = function () { };
    /**
     * @abstract
     * @return {?}
     */
    TrackAdapter.prototype.size = function () { };
    /**
     * @abstract
     * @return {?}
     */
    TrackAdapter.prototype.offset = function () { };
    /**
     * @abstract
     * @protected
     * @param {?} value
     * @return {?}
     */
    TrackAdapter.prototype.mapToScrollToOption = function (value) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ThumbAdapter {
    /**
     * @protected
     * @param {?} cmp
     * @param {?} thumbElement
     * @param {?} document
     */
    constructor(cmp, thumbElement, document) {
        this.cmp = cmp;
        this.thumbElement = thumbElement;
        this.document = document;
        // Stream that emits dragging state
        this._dragging = new Subject();
        this.dragging = this._dragging.pipe(distinctUntilChanged());
    }
    /**
     * @return {?}
     */
    get trackMax() {
        return this.track.size - this.size;
    }
    // Get thumb client rect
    /**
     * @return {?}
     */
    get clientRect() {
        return this.thumbElement.getBoundingClientRect();
    }
    // Stream that emits when scrollbar thumb is clicked
    /**
     * @return {?}
     */
    get clicked() {
        return fromEvent(this.thumbElement, 'mousedown', { passive: true }).pipe(stopPropagation());
    }
    // Calculate and update thumb position and size
    /**
     * @return {?}
     */
    update() {
        /** @type {?} */
        const size = calculateThumbSize(this.track.size, this.viewportScrollSize, (/** @type {?} */ (this.cmp.minThumbSize)));
        /** @type {?} */
        const position = calculateThumbPosition(this.viewportScrollOffset, this.viewportScrollMax, this.trackMax);
        animationFrameScheduler.schedule((/**
         * @return {?}
         */
        () => this.updateStyles(this.handleDirection(position, this.trackMax), size)));
    }
    /**
     * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
     * This function is called by thumb drag event using viewport or scrollbar pointer events
     * @param {?} event
     * @return {?}
     */
    dragged(event) {
        /** @type {?} */
        let trackMaxStart;
        /** @type {?} */
        let scrollMaxStart;
        /** @type {?} */
        const dragStart = of(event).pipe(preventSelection(this.document), tap((/**
         * @return {?}
         */
        () => {
            // Capture scrollMax and trackMax once
            trackMaxStart = this.trackMax;
            scrollMaxStart = this.viewportScrollMax;
            this.setDragging(true);
        })));
        /** @type {?} */
        const dragging = fromEvent(this.document, 'mousemove', { capture: true, passive: true }).pipe(stopPropagation());
        /** @type {?} */
        const dragEnd = fromEvent(this.document, 'mouseup', { capture: true }).pipe(stopPropagation(), enableSelection(this.document), tap((/**
         * @return {?}
         */
        () => this.setDragging(false))));
        return dragStart.pipe(pluck(this.pageProperty), map((/**
         * @param {?} pageOffset
         * @return {?}
         */
        (pageOffset) => pageOffset - this.dragStartOffset)), mergeMap((/**
         * @param {?} mouseDownOffset
         * @return {?}
         */
        (mouseDownOffset) => dragging.pipe(pluck(this.clientProperty), 
        // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).
        map((/**
         * @param {?} mouseOffset
         * @return {?}
         */
        (mouseOffset) => mouseOffset - this.track.offset)), map((/**
         * @param {?} offset
         * @return {?}
         */
        (offset) => scrollMaxStart * (offset - mouseDownOffset) / trackMaxStart)), map((/**
         * @param {?} position
         * @return {?}
         */
        (position) => this.handleDrag(position, scrollMaxStart))), tap((/**
         * @param {?} position
         * @return {?}
         */
        (position) => this.scrollTo(position))), takeUntil(dragEnd)))));
    }
}
ThumbAdapter.propDecorators = {
    track: [{ type: Input }],
    dragging: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    ThumbAdapter.prototype.track;
    /**
     * @type {?}
     * @private
     */
    ThumbAdapter.prototype._dragging;
    /** @type {?} */
    ThumbAdapter.prototype.dragging;
    /**
     * @type {?}
     * @protected
     */
    ThumbAdapter.prototype.cmp;
    /**
     * @type {?}
     * @protected
     */
    ThumbAdapter.prototype.thumbElement;
    /**
     * @type {?}
     * @protected
     */
    ThumbAdapter.prototype.document;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ThumbAdapter.prototype.pageProperty = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ThumbAdapter.prototype.clientProperty = function () { };
    /**
     * @abstract
     * @return {?}
     */
    ThumbAdapter.prototype.dragStartOffset = function () { };
    /**
     * @abstract
     * @return {?}
     */
    ThumbAdapter.prototype.size = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ThumbAdapter.prototype.viewportScrollSize = function () { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    ThumbAdapter.prototype.viewportScrollOffset = function () { };
    /**
     * @abstract
     * @return {?}
     */
    ThumbAdapter.prototype.viewportScrollMax = function () { };
    /**
     * @abstract
     * @protected
     * @param {?} value
     * @return {?}
     */
    ThumbAdapter.prototype.setDragging = function (value) { };
    /**
     * @abstract
     * @protected
     * @param {?} position
     * @return {?}
     */
    ThumbAdapter.prototype.scrollTo = function (position) { };
    /**
     * @abstract
     * @protected
     * @param {?} position
     * @param {?} size
     * @return {?}
     */
    ThumbAdapter.prototype.updateStyles = function (position, size) { };
    /**
     * @abstract
     * @protected
     * @param {?} position
     * @param {?=} scrollMax
     * @return {?}
     */
    ThumbAdapter.prototype.handleDrag = function (position, scrollMax) { };
    /**
     * @abstract
     * @protected
     * @param {?} position
     * @param {?=} scrollMax
     * @return {?}
     */
    ThumbAdapter.prototype.handleDirection = function (position, scrollMax) { };
}
/**
 * Calculate scrollbar thumb size
 * @param {?} trackSize
 * @param {?} contentSize
 * @param {?} minThumbSize
 * @return {?}
 */
function calculateThumbSize(trackSize, contentSize, minThumbSize) {
    /** @type {?} */
    const scrollbarRatio = trackSize / contentSize;
    /** @type {?} */
    const thumbSize = scrollbarRatio * trackSize;
    return Math.max(~~thumbSize, minThumbSize);
}
/**
 * Calculate scrollbar thumb position
 * @param {?} scrollPosition
 * @param {?} scrollMax
 * @param {?} trackMax
 * @return {?}
 */
function calculateThumbPosition(scrollPosition, scrollMax, trackMax) {
    return scrollPosition * trackMax / scrollMax;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThumbXDirective extends ThumbAdapter {
    /**
     * @param {?} cmp
     * @param {?} element
     * @param {?} document
     * @param {?} dir
     */
    constructor(cmp, element, document, dir) {
        super(cmp, element.nativeElement, document);
        this.cmp = cmp;
        this.element = element;
        this.document = document;
        this.dir = dir;
    }
    /**
     * @protected
     * @return {?}
     */
    get clientProperty() {
        return 'clientX';
    }
    /**
     * @protected
     * @return {?}
     */
    get pageProperty() {
        return 'pageX';
    }
    /**
     * @protected
     * @return {?}
     */
    get viewportScrollSize() {
        return this.cmp.viewport.scrollWidth;
    }
    /**
     * @protected
     * @return {?}
     */
    get viewportScrollOffset() {
        return this.cmp.viewport.scrollLeft;
    }
    /**
     * @return {?}
     */
    get viewportScrollMax() {
        return this.cmp.viewport.scrollMaxX;
    }
    /**
     * @return {?}
     */
    get dragStartOffset() {
        return this.clientRect.left;
    }
    /**
     * @return {?}
     */
    get size() {
        return this.thumbElement.clientWidth;
    }
    /**
     * @protected
     * @param {?} position
     * @param {?} size
     * @return {?}
     */
    updateStyles(position, size) {
        this.thumbElement.style.width = `${size}px`;
        this.thumbElement.style.transform = `translate3d(${position}px, 0, 0)`;
    }
    /**
     * @protected
     * @param {?} position
     * @param {?} scrollMax
     * @return {?}
     */
    handleDrag(position, scrollMax) {
        if (this.dir.value === 'rtl') {
            if (this.cmp.manager.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                return position - scrollMax;
            }
            if (this.cmp.manager.rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                return scrollMax - position;
            }
            // Keeping this as a memo
            // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {
            //   return position;
            // }
        }
        return position;
    }
    /**
     * @protected
     * @param {?} position
     * @param {?} trackMax
     * @return {?}
     */
    handleDirection(position, trackMax) {
        if (this.dir.value === 'rtl') {
            if (this.cmp.manager.rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                return -position;
            }
            if (this.cmp.manager.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {
                return position - trackMax;
            }
            // Keeping this as a memo
            // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
            //   return position;
            // }
        }
        return position;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    setDragging(value) {
        this.cmp.setDragging({ horizontalDragging: value });
    }
    /**
     * @protected
     * @param {?} position
     * @return {?}
     */
    scrollTo(position) {
        this.cmp.viewport.scrollXTo(position);
    }
}
ThumbXDirective.decorators = [
    { type: Directive, args: [{ selector: '[scrollbarThumbX]' },] }
];
/** @nocollapse */
ThumbXDirective.ctorParameters = () => [
    { type: NgScrollbar },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Directionality }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ThumbXDirective.prototype.cmp;
    /**
     * @type {?}
     * @protected
     */
    ThumbXDirective.prototype.element;
    /**
     * @type {?}
     * @protected
     */
    ThumbXDirective.prototype.document;
    /**
     * @type {?}
     * @protected
     */
    ThumbXDirective.prototype.dir;
}
class ThumbYDirective extends ThumbAdapter {
    /**
     * @param {?} cmp
     * @param {?} element
     * @param {?} document
     */
    constructor(cmp, element, document) {
        super(cmp, element.nativeElement, document);
        this.cmp = cmp;
        this.element = element;
        this.document = document;
    }
    /**
     * @protected
     * @return {?}
     */
    get pageProperty() {
        return 'pageY';
    }
    /**
     * @protected
     * @return {?}
     */
    get viewportScrollSize() {
        return this.cmp.viewport.scrollHeight;
    }
    /**
     * @protected
     * @return {?}
     */
    get viewportScrollOffset() {
        return this.cmp.viewport.scrollTop;
    }
    /**
     * @return {?}
     */
    get viewportScrollMax() {
        return this.cmp.viewport.scrollMaxY;
    }
    /**
     * @protected
     * @return {?}
     */
    get clientProperty() {
        return 'clientY';
    }
    /**
     * @return {?}
     */
    get dragStartOffset() {
        return this.clientRect.top;
    }
    /**
     * @return {?}
     */
    get size() {
        return this.thumbElement.clientHeight;
    }
    /**
     * @protected
     * @param {?} position
     * @param {?} size
     * @return {?}
     */
    updateStyles(position, size) {
        this.thumbElement.style.height = `${size}px`;
        this.thumbElement.style.transform = `translate3d(0px, ${position}px, 0)`;
    }
    /**
     * @protected
     * @param {?} position
     * @return {?}
     */
    handleDrag(position) {
        return position;
    }
    /**
     * @protected
     * @param {?} position
     * @return {?}
     */
    handleDirection(position) {
        return position;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    setDragging(value) {
        this.cmp.setDragging({ verticalDragging: value });
    }
    /**
     * @protected
     * @param {?} position
     * @return {?}
     */
    scrollTo(position) {
        this.cmp.viewport.scrollYTo(position);
    }
}
ThumbYDirective.decorators = [
    { type: Directive, args: [{ selector: '[scrollbarThumbY]' },] }
];
/** @nocollapse */
ThumbYDirective.ctorParameters = () => [
    { type: NgScrollbar },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ThumbYDirective.prototype.cmp;
    /**
     * @type {?}
     * @protected
     */
    ThumbYDirective.prototype.element;
    /**
     * @type {?}
     * @protected
     */
    ThumbYDirective.prototype.document;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrackXDirective extends TrackAdapter {
    /**
     * @param {?} cmp
     * @param {?} trackElement
     * @param {?} document
     */
    constructor(cmp, trackElement, document) {
        super(cmp, trackElement.nativeElement, document);
        this.cmp = cmp;
        this.document = document;
    }
    /**
     * @return {?}
     */
    get pageProperty() {
        return 'pageX';
    }
    /**
     * @return {?}
     */
    get offset() {
        return this.clientRect.left;
    }
    /**
     * @return {?}
     */
    get size() {
        return this.trackElement.clientWidth;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    mapToScrollToOption(value) {
        return { left: value };
    }
}
TrackXDirective.decorators = [
    { type: Directive, args: [{ selector: '[scrollbarTrackX]' },] }
];
/** @nocollapse */
TrackXDirective.ctorParameters = () => [
    { type: NgScrollbar },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    TrackXDirective.prototype.cmp;
    /**
     * @type {?}
     * @protected
     */
    TrackXDirective.prototype.document;
}
class TrackYDirective extends TrackAdapter {
    /**
     * @param {?} cmp
     * @param {?} trackElement
     * @param {?} document
     */
    constructor(cmp, trackElement, document) {
        super(cmp, trackElement.nativeElement, document);
        this.cmp = cmp;
        this.document = document;
    }
    /**
     * @return {?}
     */
    get pageProperty() {
        return 'pageY';
    }
    /**
     * @return {?}
     */
    get offset() {
        return this.clientRect.top;
    }
    /**
     * @return {?}
     */
    get size() {
        return this.trackElement.clientHeight;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    mapToScrollToOption(value) {
        return { top: value };
    }
}
TrackYDirective.decorators = [
    { type: Directive, args: [{ selector: '[scrollbarTrackY]' },] }
];
/** @nocollapse */
TrackYDirective.ctorParameters = () => [
    { type: NgScrollbar },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    TrackYDirective.prototype.cmp;
    /**
     * @type {?}
     * @protected
     */
    TrackYDirective.prototype.document;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class Scrollbar {
    /**
     * @protected
     * @param {?} cmp
     * @param {?} platform
     * @param {?} document
     * @param {?} zone
     */
    constructor(cmp, platform, document, zone) {
        this.cmp = cmp;
        this.platform = platform;
        this.document = document;
        this.zone = zone;
        // Stream that emits to unsubscribe from all streams
        this.destroyed = new Subject();
    }
    /**
     * Activate scrollbar pointer events
     * @private
     * @return {?}
     */
    activatePointerEvents() {
        // Stream that emits when scrollbar thumb is dragged
        /** @type {?} */
        let thumbDragEvent = EMPTY;
        // Stream that emits when scrollbar track is clicked
        /** @type {?} */
        let trackClickEvent = EMPTY;
        // Stream that emits when scrollbar track is hovered
        /** @type {?} */
        let trackHoveredEvent = EMPTY;
        // Set the method used for the pointer events option
        if (this.cmp.pointerEventsMethod === 'viewport') {
            // Pointer events using the viewport
            this.viewportTrackClicked = new Subject();
            this.viewportThumbClicked = new Subject();
            // Activate the pointer events of the viewport directive
            this.cmp.viewport.activatePointerEvents(this.destroyed);
            // Set streams
            thumbDragEvent = this.viewportThumbClicked;
            trackClickEvent = this.viewportTrackClicked;
            trackHoveredEvent = this.cmp.viewport.hovered.pipe(
            // Check if track is hovered
            map((/**
             * @param {?} e
             * @return {?}
             */
            (e) => isWithinBounds(e, this.track.clientRect))), distinctUntilChanged(), 
            // Enable / disable text selection
            tap((/**
             * @param {?} hovered
             * @return {?}
             */
            (hovered) => this.document.onselectstart = hovered ? (/**
             * @return {?}
             */
            () => false) : null)));
            this.cmp.viewport.clicked.pipe(tap((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (e) {
                    if (isWithinBounds(e, this.thumb.clientRect)) {
                        this.viewportThumbClicked.next(e);
                    }
                    else if (isWithinBounds(e, this.track.clientRect)) {
                        this.cmp.setClicked(true);
                        this.viewportTrackClicked.next(e);
                    }
                }
                else {
                    this.cmp.setClicked(false);
                }
            })), takeUntil(this.destroyed)).subscribe();
        }
        else {
            // Pointer events method is using 'scrollbar'
            thumbDragEvent = this.thumb.clicked;
            trackClickEvent = this.track.clicked;
            trackHoveredEvent = this.track.hovered;
        }
        return merge(
        // Activate scrollbar hovered event
        trackHoveredEvent.pipe(tap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.setHovered(e)))), 
        // Activate scrollbar thumb drag event
        thumbDragEvent.pipe(switchMap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.thumb.dragged(e)))), 
        // Activate scrollbar track click event
        trackClickEvent.pipe(switchMap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.track.onTrackClicked(e, this.thumb.size, this.viewportScrollSize)))));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            // Activate pointer events on Desktop only
            if (!(this.platform.IOS || this.platform.ANDROID) && !this.cmp.pointerEventsDisabled) {
                this.activatePointerEvents().pipe(takeUntil(this.destroyed)).subscribe();
            }
            // Stream that emits when host component is updated
            /** @type {?} */
            const updated = this.cmp.updated.pipe(tap((/**
             * @return {?}
             */
            () => this.onUpdated())));
            // Update scrollbar thumb when viewport is scrolled and when scrollbar component is updated
            merge(this.cmp.scrolled, updated).pipe(tap((/**
             * @return {?}
             */
            () => this.thumb.update())), takeUntil(this.destroyed)).subscribe();
            // Initialize scrollbar
            asyncScheduler.schedule((/**
             * @return {?}
             */
            () => this.thumb.update()), 100);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyed.next();
        this.destroyed.complete();
        // Clean up viewport streams if used
        if (this.viewportThumbClicked && this.viewportTrackClicked) {
            this.viewportTrackClicked.complete();
            this.viewportThumbClicked.complete();
        }
    }
}
if (false) {
    /** @type {?} */
    Scrollbar.prototype.thumb;
    /** @type {?} */
    Scrollbar.prototype.track;
    /**
     * @type {?}
     * @protected
     */
    Scrollbar.prototype.destroyed;
    /**
     * Viewport pointer events
     * The following streams are only activated when (pointerEventsMethod === 'viewport')
     * @type {?}
     * @protected
     */
    Scrollbar.prototype.viewportTrackClicked;
    /**
     * @type {?}
     * @protected
     */
    Scrollbar.prototype.viewportThumbClicked;
    /** @type {?} */
    Scrollbar.prototype.cmp;
    /**
     * @type {?}
     * @protected
     */
    Scrollbar.prototype.platform;
    /**
     * @type {?}
     * @protected
     */
    Scrollbar.prototype.document;
    /**
     * @type {?}
     * @protected
     */
    Scrollbar.prototype.zone;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    Scrollbar.prototype.viewportScrollSize = function () { };
    /**
     * @abstract
     * @protected
     * @param {?} value
     * @return {?}
     */
    Scrollbar.prototype.setHovered = function (value) { };
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    Scrollbar.prototype.onUpdated = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollbarY extends Scrollbar {
    /**
     * @param {?} cmp
     * @param {?} platform
     * @param {?} document
     * @param {?} zone
     */
    constructor(cmp, platform, document, zone) {
        super(cmp, platform, document, zone);
        this.cmp = cmp;
        this.platform = platform;
        this.document = document;
        this.zone = zone;
    }
    /**
     * @protected
     * @return {?}
     */
    get viewportScrollSize() {
        return this.cmp.viewport.scrollHeight;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    setHovered(value) {
        this.cmp.setHovered({ verticalHovered: value });
    }
    /**
     * @return {?}
     */
    onUpdated() {
    }
}
ScrollbarY.decorators = [
    { type: Component, args: [{
                selector: 'scrollbar-y',
                host: { '[class.scrollbar-control]': 'true' },
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <div scrollbarTrackY class="ng-scrollbar-track {{cmp.trackClass}}">
      <div scrollbarThumbY [track]="track" class="ng-scrollbar-thumb {{cmp.thumbClass}}"></div>
    </div>
  `,
                styles: ["::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control{width:var(--vertical-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track{width:var(--vertical-scrollbar-size);height:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[verticalHovered=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[deactivated=false]>scrollbar-y.scrollbar-control{top:0;bottom:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr]>scrollbar-y.scrollbar-control{right:0;left:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertAll]>scrollbar-y.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertY]>scrollbar-y.scrollbar-control{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl]>scrollbar-y.scrollbar-control{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertAll]>scrollbar-y.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertY]>scrollbar-y.scrollbar-control{left:unset;right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all]>scrollbar-y.scrollbar-control[fit=true]{bottom:var(--scrollbar-total-size);top:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertAll]>scrollbar-y.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertX]>scrollbar-y.scrollbar-control[fit=true]{top:var(--scrollbar-total-size);bottom:0}"]
            }] }
];
/** @nocollapse */
ScrollbarY.ctorParameters = () => [
    { type: NgScrollbar },
    { type: Platform },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone }
];
ScrollbarY.propDecorators = {
    track: [{ type: ViewChild, args: [TrackYDirective, { static: true },] }],
    thumb: [{ type: ViewChild, args: [ThumbYDirective, { static: true },] }]
};
if (false) {
    /** @type {?} */
    ScrollbarY.prototype.track;
    /** @type {?} */
    ScrollbarY.prototype.thumb;
    /** @type {?} */
    ScrollbarY.prototype.cmp;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarY.prototype.platform;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarY.prototype.document;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarY.prototype.zone;
}
class ScrollbarX extends Scrollbar {
    /**
     * @param {?} el
     * @param {?} cmp
     * @param {?} platform
     * @param {?} document
     * @param {?} zone
     */
    constructor(el, cmp, platform, document, zone) {
        super(cmp, platform, document, zone);
        this.el = el;
        this.cmp = cmp;
        this.platform = platform;
        this.document = document;
        this.zone = zone;
    }
    /**
     * @protected
     * @return {?}
     */
    get viewportScrollSize() {
        return this.cmp.viewport.scrollWidth;
    }
    /**
     * @return {?}
     */
    get thickness() {
        return this.el.nativeElement.clientHeight;
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    setHovered(value) {
        this.cmp.setHovered({ horizontalHovered: value });
    }
    /**
     * @return {?}
     */
    onUpdated() {
        // Auto-height: Set root component height to content height
        this.cmp.nativeElement.style.height = this.cmp.appearance === 'standard'
            ? `${this.cmp.viewport.contentHeight + this.thickness}px`
            : `${this.cmp.viewport.contentHeight}px`;
    }
}
ScrollbarX.decorators = [
    { type: Component, args: [{
                selector: 'scrollbar-x',
                host: { '[class.scrollbar-control]': 'true' },
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <div scrollbarTrackX class="ng-scrollbar-track {{cmp.trackClass}}">
      <div scrollbarThumbX [track]="track" class="ng-scrollbar-thumb {{cmp.thumbClass}}"></div>
    </div>
  `,
                styles: ["::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control{height:var(--horizontal-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{width:0;height:100%}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[horizontalHovered=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[position=invertAll]>scrollbar-x.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[position=invertX]>scrollbar-x.scrollbar-control{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false]>scrollbar-x.scrollbar-control{left:0;right:0;bottom:0;top:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][position=invertAll]>scrollbar-x.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][position=invertX]>scrollbar-x.scrollbar-control{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertAll]>scrollbar-x.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertY]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertAll]>scrollbar-x.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertY]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}"]
            }] }
];
/** @nocollapse */
ScrollbarX.ctorParameters = () => [
    { type: ElementRef },
    { type: NgScrollbar },
    { type: Platform },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone }
];
ScrollbarX.propDecorators = {
    track: [{ type: ViewChild, args: [TrackXDirective, { static: true },] }],
    thumb: [{ type: ViewChild, args: [ThumbXDirective, { static: true },] }]
};
if (false) {
    /** @type {?} */
    ScrollbarX.prototype.track;
    /** @type {?} */
    ScrollbarX.prototype.thumb;
    /**
     * @type {?}
     * @private
     */
    ScrollbarX.prototype.el;
    /** @type {?} */
    ScrollbarX.prototype.cmp;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarX.prototype.platform;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarX.prototype.document;
    /**
     * @type {?}
     * @protected
     */
    ScrollbarX.prototype.zone;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgScrollbarModule {
}
NgScrollbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    BidiModule,
                    PortalModule,
                    PlatformModule,
                    SmoothScrollModule
                ],
                declarations: [
                    NgScrollbar,
                    ScrollViewport,
                    CssVariable,
                    NgAttr,
                    ResizeSensor,
                    ThumbYDirective,
                    ThumbXDirective,
                    TrackXDirective,
                    TrackYDirective,
                    ScrollbarY,
                    ScrollbarX
                ],
                exports: [
                    NgScrollbar,
                    ScrollViewport
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NG_SCROLLBAR_OPTIONS, NgScrollbar, NgScrollbarModule, ScrollViewport, ScrollbarManager, NativeScrollbarSizeFactory as ɵa, CssVariable as ɵb, NgAttr as ɵc, ResizeObserverFactory as ɵd, ResizeSensor as ɵe, ThumbXDirective as ɵf, ThumbYDirective as ɵg, ThumbAdapter as ɵh, TrackXDirective as ɵi, TrackYDirective as ɵj, TrackAdapter as ɵk, ScrollbarY as ɵl, ScrollbarX as ɵm, Scrollbar as ɵn };
//# sourceMappingURL=ngx-scrollbar.js.map
